#' PlotPDF
#'
#' Takes a list of plots generated by \pkg{ascend} and prints them to PDF.
#' @param plot.list A list of plots generated by \pkg{ascend}
#' @param filename Name of the file you would like to output to
#' @param width Width of the PDF
#' @param height Height of the PDF
#' @export
#'
PlotPDF <- function(plot.list, filename = NULL, width = 11, height = 8.5){
  if (missing(filename)){
    stop("Please specify a filename.")
  }

  # Set file to print out to
  pdf(filename, width = width, height = height)
  for (plot.name in names(plot.list)){
    plot <- plot.list[[plot.name]]
    if (length(class(plot)) == 1){
      if (is.list(plot)){
        for (x in plot){
          print(x)
        }
      }
    } else{
      print(plot)
    }
  }
  dev.off()
}

# Unlog matrix - required if object was normalised with scran's deconvolution method
#' UnLog2Matrix
#'
#' Converts count values of a matrix that had undergone normalisation via scran's deconvolution method.
#' @param expression.matrix An expression.matrix
#'
UnLog2Matrix <- function(expression.matrix){
  unlog.matrix <-apply(expression.matrix, 1, function(x) 2^x)
  unlog.matrix.sub.1 <- unlog.matrix -1
  unlog.matrix.sub.1[unlog.matrix.sub.1 < 0] <- 0
  unlog.matrix.pos <- Matrix::t(unlog.matrix.sub.1)
  return(unlog.matrix.pos)
}

#' ChunkMatrix
#'
#' Chunks a matrix randomly - either along rows or columns
#' @param expression.matrix An expression matrix to chunk
#' @param axis Specify either 0 (rows) or 1 (columns)
#' @param chunks Number of chunks you would like to break the matrix into
#' @export
#'
ChunkMatrix <- function(expression.matrix, axis=0, chunks = 1){
  if(missing(axis)){
    stop("Please specify axis: 'rows' or 'columns'...")
  }

  if (axis == 0){
    print("Chunking expression matrix by rows...")
    nelements <- nrow(expression.matrix)
  } else if (axis == 1){
    print("Chunking expression matrix by columns...")
    nelements <- ncol(expression.matrix)
  } else{
    stop("Please select which axis to chunk by: rows(0) or columns(1)...")
  }

  # Generate indexes to chunk
  whole.chunks <- nelements %/% chunks
  partial.chunks <- nelements - (whole.chunks * chunks)

  # Output for chunked data
  chunk.list <- list()

  # Generate a random list of numbers, this will make the order random
  set.seed(0)
  random.list <- sample(1:nelements, nelements, replace = F)

  for (x in 1:chunks){
    # Add on leftovers to original chunks
    chunk <- whole.chunks
    if (x == 1){
      chunk <- chunk + partial.chunks
    }

    # Start generating a random list of numbers
    # Remove the indexes from the list if they have been selected
    selected.list <- sample(random.list, chunk, replace = F)
    random.list <- random.list[! random.list %in% selected.list]

    if(axis == 0){
      chunk.list[[as.character(x)]] <- expression.matrix[selected.list, ]
    }

    if(axis == 1){
      chunk.list[[as.character(x)]] <- expression.matrix[ ,selected.list]
    }

  }

  chunk.idx <- split(sample(1:nelements), 1:chunks)

  if(axis == 0){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[x,])
  }

  if(axis == 1){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[,x])
  }

  return(chunk.list)
}

# Combine different matrix dataframes into one large matrix
#' JoinMatrices
#'
#' Merge a list of expression matrices in data frame format into one large data frame.
#' @param x A list of data frames containing expression matrices.
#' @param format Output joined matrices in one of the following formats: data.frame, matrix or sparseMatrix. DEFAULT: data.frame
#' @export
#'
JoinMatrices <- function(x = list(), format = c("data.frame", "matrix", "sparseMatrix")){
  # Basic checks
  ## Ensure we have a list of matrices
  if (!is.list(x)){
    stop("Please specify a list of matrices.")
  } else{
    # Sparse matrices
    if (all(sapply(x, function(x) is(x, "sparseMatrix")))){
      input.format <- "sparseMatrix" 
    } else if(all(sapply(x, is.data.frame))){
      input.format <- "data.frame"
    } else if(all(sapply(x, is.matrix))){
      input.format <- "matrix"
    } 
    else{
      stop("Please ensure your list is comprised of one of the following: data.frame, matrix, sparseMatrix")
    }
  }
  
  ## Ensure output format has a format - default format is data frame
  if (missing(format)){
    format <- "data.frame"
  }
  
  # Generate a new list of rownames and colnames for the new combined matrix
  gene.list <- unique(as.vector(unlist(sapply(x, rownames))))
  cell.list <- as.vector(unlist(sapply(x, colnames)))
  
  # Check if there are any duplicates in the cell barcodes. Stop if duplicates are detected.
  if (any(duplicated(cell.list))){
    duplicated.cells <- gene.list[anyDuplicated(cell.list)]
    stop(sprintf("%i duplicate cell barcodes detected. Please check your cell barcodes before trying again.", length(duplicated.cells)))
  }
  
  # Join matrices based on input format
  
  if (input.format == "sparseMatrix"){
    ## Snippet by @sushilashenoy on Github - THANK YOU!
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.sum <- Matrix::summary(mat) # Get i,j,x format for sparse matrix
      map.genes <- match(rownames(mat), gene.list)
      new.i <- map.genes[mat.sum$i]
      Matrix::sparseMatrix(i=new.i, j=mat.sum$j, x=mat.sum$x, dims=c(length(gene.list), ncol(mat)), dimnames=list(gene.list, paste0(colnames(mat), "-", batch.id)))      
    })
  } else if(input.format == "matrix"){
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.2 <- rbind(mat, matrix(rep(0, (length(gene.list) - nrow(mat)) * ncol(mat)), ncol = ncol(mat), nrow = length(gene.list) - nrow(mat)))
      new.rownames <- c(gene.list[rownames(mat.2) %in% gene.list], gene.list[!(rownames(mat.2) %in% gene.list)])
      rownames(mat.2) <- new.rownames
      colnames(mat.2) <- paste0(colnames(mat.2), "-", batch.id)
      return(mat.2)
    })
  } else if(input.format == "data.frame"){
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.2 <- mat[gene.list,]
      rownames(mat.2) <- gene.list
      mat.2[is.na(mat.2)] <- 0
      colnames(mat.2) <- paste0(colnames(mat.2), "-", batch.id)
      return(mat.2)
    })
  }
  output <- do.call(cbind, matrices)
  
  if (input.format != format){
   output <- ConvertMatrix(output, format)
  }
  return(output)
}

#' ConvertMatrix
#'
#' Converts matrix to format of choice. This function gets called by other functions.
#'
#' @param matrix A data frame, dense matrix or sparse matrix.
#' @param format Format to change the matrix to.
#' @export
#'
ConvertMatrix <- function(matrix, format = c("data.frame", "matrix", "sparseMatrix")){
  # Make sure format is specified correctly
  if (!any(format %in% c("data.frame", "matrix", "sparseMatrix"))){
    stop("Please specify format as one of the following: data.frame, matrix or sparseMatrix")
  }

  # Dense matrix
  if (is.matrix(matrix)){
    if (format == "data.frame"){
      output <- as.data.frame(matrix)
    }
    else if (format == "sparseMatrix"){
      output <- Matrix::Matrix(matrix, sparse = TRUE)
    } else{
      output <- matrix
    }
  }

  # Data frame
  else if (is.data.frame(matrix)){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "sparseMatrix"){
      output <- Matrix::Matrix(as.matrix(matrix), sparse = TRUE)
    }
    else{
      output <- matrix
    }
  }

  # Sparse matrix
  else if (is(matrix, "sparseMatrix")){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "data.frame"){
      output <- as.data.frame(as.matrix(matrix))
    }
    else{
      output <- matrix
    }
  }

  else{
    stop("Please provide a matrix of one of the following types: data.frame, matrix or sparse matrix.")
  }

  # Whatever it is, return something
  return(output)
}

# Function - generic check if it exists
# Basic function to check if all items in one list, is present in another list
CheckData <- function(object, query) {
  matches <- !all(is.na(match(query, object)))
  return(matches)
}

# This little snippet is designed in a way in which you pair it up with a call to process the file
FileCheck <- function(filename) {
  if (!(file.exists(filename))) {
    stop(sprintf("%s is missing", filename))
  } else {
    return(FALSE)
  }
}
