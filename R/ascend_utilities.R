#' PlotPDF
#'
#' Takes a list of plots generated by \pkg{ascend} and prints them to PDF. As 
#' this is a wrapper for the \link[grDevices]{pdf} function, you can pass additional
#' arguments to this function.
#' 
#' @param plot.list A list of plots generated by \pkg{ascend}.
#' @param filename Name of the file you would like to output to.
#' @param width Width of the PDF.
#' @param height Height of the PDF.
#' @param ... Additional arguments to pass on to \code{\link{pdf}} function
#' @examples
#' \dontrun{
#' qc.plots <- PlotGeneralQC(em.set)
#' PlotPDF(qc.plots, filename = "MyQCplots.pdf", 
#' width = 11, height = 8.5, bg = "white")
#' }
#' @importFrom grDevices pdf dev.off
#' @export
#'
PlotPDF <- function(plot.list, filename = NULL, width = 11, height = 8.5, ...){
  if (missing(filename)){
    stop("Please specify a filename.")
  }

  # Set file to print out to
  pdf(filename, width = width, height = height, ...)
  for (plot.name in names(plot.list)){
    plot <- plot.list[[plot.name]]
    if (length(class(plot)) == 1){
      if (is.list(plot)){
        for (x in plot){
          print(x)
        }
      }
    } else{
      print(plot)
    }
  }
  dev.off()
}

# Unlog matrix - required if object was normalised with scran's deconvolution method
#' UnLog2Matrix
#'
#' Converts count values of a matrix that had undergone normalisation via 
#' scran's deconvolution method. This converts the log2 values + 1 pseudocount
#' values back into transcript count values.
#' 
#' @param expression.matrix An expression.matrix.
#' @return The expression matrix in dense matrix format.
#' @examples
#' \dontrun{
#' unlogged.matrix <- Unlog2Matrix(expression.matrix)
#' }
#' @importFrom Matrix t
#' @export
UnLog2Matrix <- function(expression.matrix){
  unlog.matrix <-apply(expression.matrix, 1, function(x) 2^x)
  unlog.matrix.sub.1 <- unlog.matrix -1
  unlog.matrix.sub.1[unlog.matrix.sub.1 < 0] <- 0
  unlog.matrix.pos <- Matrix::t(unlog.matrix.sub.1)
  return(unlog.matrix.pos)
}

#' ChunkMatrix
#'
#' Chunks a matrix randomly - either along rows or columns
#' @param expression.matrix An expression matrix to chunk.
#' @param axis Specify either 0 (rows) or 1 (columns).
#' @param chunks Number of chunks you would like to break the matrix into.
#' @return A list of matrices.
#' @examples
#' my_matrix <- matrix(replicate(10, rnorm(20)))
#' chunked_matrix <- ChunkMatrix(my_matrix, axis = 0, chunks = 5)
#' @export
#'
ChunkMatrix <- function(expression.matrix, axis=0, chunks = 1){
  if(missing(axis)){
    stop("Please specify axis: 'rows' or 'columns'...")
  }

  if (axis == 0){
    print("Chunking expression matrix by rows...")
    nelements <- nrow(expression.matrix)
  } else if (axis == 1){
    print("Chunking expression matrix by columns...")
    nelements <- ncol(expression.matrix)
  } else{
    stop("Please select which axis to chunk by: rows(0) or columns(1)...")
  }

  # Generate indexes to chunk
  whole.chunks <- nelements %/% chunks
  partial.chunks <- nelements - (whole.chunks * chunks)

  # Output for chunked data
  chunk.list <- list()

  # Generate a random list of numbers, this will make the order random
  set.seed(0)
  random.list <- sample(1:nelements, nelements, replace = FALSE)

  for (x in 1:chunks){
    # Add on leftovers to original chunks
    chunk <- whole.chunks
    if (x == 1){
      chunk <- chunk + partial.chunks
    }

    # Start generating a random list of numbers
    # Remove the indexes from the list if they have been selected
    selected.list <- sample(random.list, chunk, replace = FALSE)
    random.list <- random.list[! random.list %in% selected.list]

    if(axis == 0){
      chunk.list[[as.character(x)]] <- expression.matrix[selected.list, ]
    }

    if(axis == 1){
      chunk.list[[as.character(x)]] <- expression.matrix[ ,selected.list]
    }

  }

  chunk.idx <- split(sample(1:nelements), 1:chunks)

  if(axis == 0){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[x,])
  }

  if(axis == 1){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[,x])
  }

  return(chunk.list)
}

# Combine different matrix dataframes into one large matrix
#' JoinMatrices
#'
#' Merge a list of expression matrices into one large matrix.
#' 
#' @param x A list of data frames containing expression matrices.
#' @param format Output joined matrices in one of the following formats: 
#' data.frame (Default), matrix or sparseMatrix.
#' @return A single expression matrix in your chosen format.
#' @examples
#' \dontrun{
#' matrix_list <- c(matrix1, matrix2, matrix3)
#' joined_matrix <- JoinMatrices(matrix_list, format = "data.frame")
#' }
#' @importFrom methods is
#' @importFrom Matrix summary sparseMatrix
#' @export
#'
JoinMatrices <- function(x = list(), format = c("data.frame", "matrix", "sparseMatrix")){
  # Basic checks
  ## Ensure we have a list of matrices
  if (!is.list(x)){
    stop("Please specify a list of matrices.")
  } else{
    # Sparse matrices
    if (all(sapply(x, function(x) is(x, "sparseMatrix")))){
      input.format <- "sparseMatrix" 
    } else if(all(sapply(x, is.data.frame))){
      input.format <- "data.frame"
    } else if(all(sapply(x, is.matrix))){
      input.format <- "matrix"
    } 
    else{
      stop("Please ensure your list is comprised of one of the following: data.frame, matrix, sparseMatrix")
    }
  }
  
  ## Ensure output format has a format - default format is data frame
  if (missing(format)){
    format <- "data.frame"
  }
  
  # Generate a new list of rownames and colnames for the new combined matrix
  gene.list <- unique(as.vector(unlist(sapply(x, rownames))))
  cell.list <- as.vector(unlist(sapply(x, colnames)))
  
  # Check if there are any duplicates in the cell barcodes. Stop if duplicates are detected.
  if (any(duplicated(cell.list))){
    duplicated.cells <- gene.list[anyDuplicated(cell.list)]
    stop(sprintf("%i duplicate cell barcodes detected. Please check your cell barcodes before trying again.", length(duplicated.cells)))
  }
  
  # Join matrices based on input format
  
  if (input.format == "sparseMatrix"){
    ## Snippet by @sushilashenoy on Github - THANK YOU!
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.sum <- Matrix::summary(mat) # Get i,j,x format for sparse matrix
      map.genes <- match(rownames(mat), gene.list)
      new.i <- map.genes[mat.sum$i]
      Matrix::sparseMatrix(i=new.i, j=mat.sum$j, x=mat.sum$x, dims=c(length(gene.list), ncol(mat)), dimnames=list(gene.list, paste0(colnames(mat), "-", batch.id)))      
    })
  } else if(input.format == "matrix"){
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.2 <- rbind(mat, matrix(rep(0, (length(gene.list) - nrow(mat)) * ncol(mat)), ncol = ncol(mat), nrow = length(gene.list) - nrow(mat)))
      new.rownames <- c(gene.list[rownames(mat.2) %in% gene.list], gene.list[!(rownames(mat.2) %in% gene.list)])
      rownames(mat.2) <- new.rownames
      mat.2 <- mat.2[gene.list,]
      colnames(mat.2) <- paste0(colnames(mat.2), "-", batch.id)
      return(mat.2)
    })
  } else if(input.format == "data.frame"){
    matrices <- lapply(seq_along(x), function(batch.id){
      mat <- x[[batch.id]]
      mat.2 <- mat[gene.list,]
      rownames(mat.2) <- gene.list
      mat.2[is.na(mat.2)] <- 0
      colnames(mat.2) <- paste0(colnames(mat.2), "-", batch.id)
      return(mat.2)
    })
  }
  output <- do.call(cbind, matrices)
  
  if (input.format != format){
   output <- ConvertMatrix(output, format)
  }
  return(output)
}

#' ConvertMatrix
#'
#' Converts matrix to format of choice. This function gets called by other 
#' functions.
#'
#' @param matrix A data frame, dense matrix or sparse matrix.
#' @param format Format to change the matrix to - "data.frame" (Default), 
#' "matrix" and "sparseMatrix".
#' @return Matrix in the format of your choice.
#' 
#' @examples
#' my_matrix <- matrix(replicate(10, rnorm(20)))
#' my_dataframe <- ConvertMatrix(my_matrix, format = "data.frame")
#' 
#' @importFrom methods is
#' @importFrom Matrix Matrix
#' @export
#'
ConvertMatrix <- function(matrix, format = c("data.frame", "matrix", "sparseMatrix")){
  # Make sure format is specified correctly
  if (!any(format %in% c("data.frame", "matrix", "sparseMatrix"))){
    stop("Please specify format as one of the following: data.frame, matrix or sparseMatrix")
  }

  # Dense matrix
  if (is.matrix(matrix)){
    if (format == "data.frame"){
      output <- as.data.frame(matrix)
    }
    else if (format == "sparseMatrix"){
      output <- Matrix::Matrix(matrix, sparse = TRUE)
    } else{
      output <- matrix
    }
  }

  # Data frame
  else if (is.data.frame(matrix)){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "sparseMatrix"){
      output <- Matrix::Matrix(as.matrix(matrix), sparse = TRUE)
    }
    else{
      output <- matrix
    }
  }

  # Sparse matrix
  else if (is(matrix, "sparseMatrix")){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "data.frame"){
      output <- as.data.frame(as.matrix(matrix))
    }
    else{
      output <- matrix
    }
  }

  else{
    stop("Please provide a matrix of one of the following types: data.frame, matrix or sparse matrix.")
  }

  # Whatever it is, return something
  return(output)
}

#' CheckData
#' Basic function to check if all the items in one list, is present in another 
#' list
#' @param object List 1.
#' @param query List 2.
#' @return List of missing objects
#' @export
CheckData <- function(object, query) {
  matches <- !all(is.na(match(query, object)))
  return(matches)
}

#' FileCheck 
#' This little snippet is designed in a way in which you pair it up with a call 
#' to process the file. This checks if the file exists.
#' 
#' @param filename Name of the file you want to check.
#' @return Returns a boolean
#' @export
FileCheck <- function(filename) {
  if (!(file.exists(filename))) {
    stop(sprintf("%s is missing", filename))
  } else {
    return(FALSE)
  }
}
