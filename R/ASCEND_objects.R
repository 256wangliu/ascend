CheckAEMSet <- function(object) {
  # This variable is where all error messages generated by the next few
  # steps get directed to
  errors <- character()

  # Check expression matrix using plyr's empty function.
  if (plyr::empty(object@ExpressionMatrix)) {
    msg <-
      "The expression matrix is empty. Please load an expression matrix."
    errors <- c(errors, msg)
  }

  # Check if there are any NA values in the expression matrix
  if (any(is.na(object@ExpressionMatrix))) {
    msg <-
      "There are NA values in the expression matrix. Please remove these values from the matrix."
    errors <- c(errors, msg)
  }

  # Check there are no duplicates in the colnames and rownames of the
  # expression matrix
  if (any(duplicated(colnames(object@ExpressionMatrix)))) {
    msg <-
      "Duplicate column names are present. Please check the expression matrix."
    errors <- c(errors, msg)
  }

  if (any(duplicated(rownames(object@ExpressionMatrix)))) {
    msg <-
      "Duplicate row names are present. Please check the expression matrix."
    errors <- c(errors, msg)
  }

  # Control checks Check if there are any controls loaded
  if (length(object@Controls) > 0) {
    ## Verify listed controls are present in the expression matrix
    check.controls <-
      unlist(object@Controls) %in% rownames(object@ExpressionMatrix)
    if (!all(check.controls)) {
      msg <-
        "Please make sure the gene identifiers you have listed in your control list matches those used in the expression matrix."
      errors <- c(errors, msg)
    }
  } else {
    msg <- "Please make sure that you have defined a control."
    errors <- c(errors, msg)
  }

  # Batch label check This step is optional
  if (length(object@BatchInformation) > 0) {
    ## Check if number of batch identifiers match the number of columns in
    ## the expression matrix
    if (length(object@BatchInformation) != length(colnames(object@ExpressionMatrix))) {
      msg <-
        "Please check your batch information. Number of batch labels does not match the number of cells listed in the expression matrix."
    } else {
      ## Check if the batch identifiers are linked to cell barcodes in the
      ## expression matrix
      if (!all(colnames(object@ExpressionMatrix) %in% names(object@BatchInformation))) {
        msg <-
          "Please make sure the list supplied to BatchInformation slot is formatted as follows: Cell Identifier, Batch Number"
      }
    }
  }

  # Check if the annotation data matches rownames in the expression matrix
  if (!plyr::empty(object@GeneAnnotation)) {
    check.annotations <-
      lapply(object@GeneAnnotation, function(x)
        CheckData(x, rownames(object@ExpressionMatrix)))
    if (!TRUE %in% check.annotations) {
      msg <-
        "Please check your annotation list. All genes in the expression matrix must be found in the gene annotation."
      errors <- c(errors, msg)
    }
  }

  # Check if conditions are properly formatted
  if (length(object@Conditions) > 0) {
    # For each defined condition, there must be a positive and negative
    # list of cell barcodes
    for (condition in object@Conditions) {
      if (names(condition) != 2) {
        msg <-
          "Please ensure you have grouped the cells into positive and negative condition groups."
        errors <- c(errors, msg)
      }
    }
  }

  # If all is well, object is valid. If not, it's invalid.
  if (length(errors) == 0) {
    TRUE
  } else{
    errors
  }
}

# ASCEND Expression and Metadata Set Class Definition
#' ASCEND Expression and Metadata Set (AEMSet)
#'
#' An S4 class to contain data in a format ASCEND can work with for analysis.
#' @slot ExpressionMatrix Transcript counts stored as a sparse matrix, where rows are transcript/gene identifiers and columns are invididual cells.
#' @slot GeneAnnotation A data frame containing information on genes and their corresponding identifiers, such as gene names and ENSEMBL transcript identifiers.
#' @slot BatchInformation A named list containing each cell identifier and its associated batch/sample.
#' @slot Controls A named list featuring gene identifiers to use as controls. These gene identifiers must match the identifiers used in the expression matrix.
#' @slot Conditions A named list containing a list of conditions and what category each cell identifier falls into.
#' @slot PCA Objects related to dimension reduction, such as a PCA matrix, a reduced PCA matrix and a list of percentage variance values per principle component. Populated by \code{\link{RunPCA}}.
#' @slot TSNE TSNE-reduced matrices used for plotting. Populated by \code{\link{PlotTSNE}}.
#' @slot Clusters Objects related to clustering, including a distance matrix, a hclust object, cell identifiers and their associated cluster. Populated by \code{\link{FindOptimalClusters}}.
#' @slot DifferentialExpression Differential expression results from DESeq. Populated by \code{\link{RunDiffExpression}} and \code{\link{RunClusterDiffExpression}}.
#' @slot Metrics A list of values generated by the \code{\link{GenerateMetrics}} function.
#' @slot Log A record of functions used on an \linkS4class{AEMSet}.
#'
setClass(
  "AEMSet",
  representation(
    ExpressionMatrix = "Matrix",
    GeneAnnotation = "data.frame",
    BatchInformation = "list",
    Controls = "list",
    PCA = "list",
    TSNE = "list",
    Conditions = "list",
    Clusters = "list",
    DifferentialExpression = "list",
    Metrics = "list",
    Log = "list"
  ),
  prototype(
    ExpressionMatrix = Matrix::Matrix(
      0,
      nrow = 0,
      ncol = 0,
      sparse = TRUE
    ),
    GeneAnnotation = data.frame(matrix(nr = 0, nc = 0)),
    BatchInformation = list(),
    Controls = list(),
    Conditions = list(),
    PCA = list(),
    TSNE = list(),
    Clusters = list(),
    DifferentialExpression = list(),
    Metrics = list(),
    Log = list()
  ),
  validity = CheckAEMSet
)

# More methods for this class
#' show
#'
#' Displays a summary of the S4 object \linkS4class{AEMSet}
#' @details AEMSet summary
#' \itemize{
#' \item{\strong{Expression Matrix} - Number of cells and genes in the original expression matrix.}
#' \item{\strong{Controls} - Number of genes listed in each control group.}
#' \item{\strong{Filtering} - Details of any filtering the object has undergone.}
#' \item{\strong{Samples} - Number of samples/batches in the experiment.}
#' \item{\strong{Clusters} - If generated, the number of clusters and their associated sizes.}
#' \item{\strong{Log} - A record of methods used on the \linkS4class{AEMSet}.}
#' }
#'
setMethod("show", signature("AEMSet"), function(object) {
  # Get number of genes and cells from the expression matrix dimensions
  print("ASCEND Object - AEMSet")
  n.genes <- dim(object@ExpressionMatrix)[1]
  n.cells <- dim(object@ExpressionMatrix)[2]
  expression.matrix.str <-
    sprintf("Expression Matrix: %i cells and %i genes",
            n.cells, n.genes)
  print(expression.matrix.str)
  print("Controls:")
  for (control.name in names(object@Controls)) {
    n.control.genes <- length(unlist(object@Controls[control.name]))
    control.str <-
      sprintf("%s: %i genes", control.name, n.control.genes)
    print(control.str)
  }

  if (length(object@Log) > 0) {
    print(object@Log)
  }

  if (length(object@Clusters) > 0) {
    if (length(object@Clusters$ClusterList) > 0) {
      clusters <- object@Clusters$ClusterList
      ncluster <- length(unique(clusters))
      cluster.str <- sprintf("Number of Clusters: %i", ncluster)
      print(cluster.str)
      print("Cluster sizes:")
      count.table <- table(clusters)
      print(count.table)
    }
  }
})


#' GenerateControlMetrics
#'
#' Function called by \code{\link{GenerateMetrics}} to generate metrics for control-related statistics.
#'
#' @param x Name of a control listed in Controls
#' @param expression.matrix Transcript counts stored in a sparse matrix object
#' @param control.list A list of controls supplied by the user
#' @param total.counts List of total counts generated by \code{\link{GenerateMetrics}}
#'
GenerateControlMetrics <-
  function(x,
           expression.matrix = NULL,
           control.list = NULL,
           total.counts = NULL) {
    control.group <- control.list[[x]]
    control.bool <- rownames(expression.matrix) %in% control.group
    control.transcript.counts <- expression.matrix[control.bool,]
    control.transcript.total.counts <-
      Matrix::colSums(control.transcript.counts)
    control.pt.matrix <-
      (control.transcript.total.counts / total.counts) * 100
    named.list <-
      list(ControlTranscriptCounts = control.transcript.total.counts,
           PercentageTotalCounts = control.pt.matrix)
    output.list <- list()
    output.list[[x]] <- named.list
    return(output.list)
  }

# Constructor function for AEMSet
#' NewAEMSet
#'
#' \code{\link{NewAEMSet}} generates a \linkS4class{AEMSet} object for use with the ASCEND package. This object contains an expression matrix, associated metadata, downstream analysis and a log documenting the actions taken to generate this object.
#' @param ExpressionMatrix An expression matrix in data.frame, dgCMatrix (sparse) or matrix format. Rows should represent a transcript and its counts, while columns should represent individual cells. This is usually the end point for Single Cell RNA-Seq pipelines such as Cell Ranger and DropSeq.
#' @param Controls A named list of controls, eg. mitochondrial genes, ribosomal genes and ERCC spike-ins. These genes must be specified using the identifier used in the expression matrix. This is required.
#' @param GeneAnnotation A data frame containing gene identifiers used in the expression matrix. Other columns can be used to represent corresponding identifiers in other formats (such as ENSEMBL transcript IDs). This is an optional field, and is best used if you need to convert between identifiers.
#' @param BatchInformation A named list of cell identifiers (usually barcodes) and an integer representing which batch they belong to. This is an optional field, and it best used for experiments that contain data from multiple samples.
#' @param Conditions A named list of conditions for use in differential expression. Supplying this information is optional.
#' @return This function generates an object belonging to the \linkS4class{AEMSet}.
#' @seealso \linkS4class{AEMSet}
#'
NewAEMSet <-
  function(ExpressionMatrix = NULL,
           GeneAnnotation = NULL,
           BatchInformation = NULL,
           Controls = list(Mt = list(), Rb = list())) {
    # Check that we have the essential arguments
    arg.check <-
      list(ExpressionMatrix = missing(ExpressionMatrix),
           Controls = missing(Controls))
    if (any(arg.check == TRUE)) {
      missing.args <- names(which(arg.check == TRUE))
      msg <-
        sprintf(
          "Please check that you have supplied the following arguments: %s\n",
          as.character(unlist(missing.args))
        )
      stop(msg)
    }

    # Automatically generate batch labels if it's not defined.
    if (is.null(BatchInformation)) {
      BatchInformation <-
        setNames(rep(1, ncol(ExpressionMatrix)), as.list(colnames(ExpressionMatrix)))
      BatchInformation <- as.list(BatchInformation)
    }

    # Automatically generate a gene annotation data frame if one hasn't
    # been supplied.
    if (is.null(GeneAnnotation)) {
      GeneAnnotation <- data.frame(gene_id = rownames(ExpressionMatrix))
    }

    # Convert the data.frame input into a sparse matrix
    if (is.data.frame(ExpressionMatrix)) {
      sparse.matrix <- LoadSparseMatrix(ExpressionMatrix)
    } else if (is.matrix(ExpressionMatrix)) {
      sparse.matrix <- Matrix::Matrix(ExpressionMatrix, sparse = TRUE)
    } else if (is(ExpressionMatrix, "sparseMatrix")) {
      sparse.matrix <- ExpressionMatrix
    } else {
      stop(
        "Please supply an expression matrix in one of the following formats: data.frame, dgCmatrix or matrix"
      )
    }

    # Create a new AEMSet object.
    sea.set <-
      new(
        "AEMSet",
        ExpressionMatrix = sparse.matrix,
        GeneAnnotation = GeneAnnotation,
        BatchInformation = BatchInformation,
        Controls = Controls
      )
    sea.set.metrics <- GenerateMetrics(sea.set)
    return(sea.set.metrics)
  }

#' GenerateMetrics
#'
#' This function generates the following set of values per cell:
#' \itemize{
#' \item{\strong{Total Counts}: Total number of expressed transcripts per cell}
#' \item{\strong{Total Feature Counts per Cell}: Number of non-control genes expressed per cell}
#' \item{\strong{Total Expression}: Total number of expressed transcripts in the dataset}
#' \item{\strong{Top Gene List}: Entire list of genes organised from most expressed to least expressed across the entire dataset}
#' \item{\strong{Control Transcript Counts}: Total sum of control transcript counts per cell}
#' \item{\strong{Percentage Total Counts}: Percentage of transcripts originating from control genes per cell}
#' \item{\strong{AverageCounts}: Average transcript count for a gene}
#' \item{\strong{GenesPerCell}: Number of unique transcripts expressed by a cell}
#' \item{\strong{CellsPerGene}: Number of cells expressing a gene}
#' \item{\strong{CountsPerGene}: Total number of transcripts produced by that gene expressed by all cells}
#' \item{\strong{Mean Gene Expression}: Mean expression level of a gene across the entire dataset}
#' }
#'
#' This function is called by \code{\link{NewAEMSet}} and generates metrics for the new expression matrix.
#' This function can also be called independantly, to update the metrics for a \linkS4class{AEMSet} object.
setGeneric(
  name = "GenerateMetrics",
  def = function(object) {
    standardGeneric("GenerateMetrics")
  }
)

setMethod("GenerateMetrics", signature("AEMSet"), function(object) {
  # Retrieve required objects from AEMSet
  expression.matrix <- object@ExpressionMatrix
  control.list <- object@Controls

  ### Calculate library size per cell
  total.counts <- Matrix::colSums(expression.matrix)

  # Prepare outputs
  control.transcript.counts.list <- list()
  percentage.lists.counts.list <- list()

  # Generate Metrics
  print("Calculating control metrics...")
  control.counts <-
    BiocParallel::bplapply(
      names(control.list),
      GenerateControlMetrics,
      expression.matrix = expression.matrix,
      control.list = control.list,
      total.counts = total.counts
    )

  # Unpackage stats
  unpacked.control.counts <-
    unlist(control.counts, recursive = FALSE)
  percentage.lists.counts.list <-
    lapply(names(unpacked.control.counts),
           function(x)
             unpacked.control.counts[[x]][["PercentageTotalCounts"]])
  names(percentage.lists.counts.list) <-
    names(unpacked.control.counts)
  control.transcript.counts.list <-
    lapply(names(unpacked.control.counts),
           function(x)
             unpacked.control.counts[[x]][["ControlTranscriptCounts"]])
  names(control.transcript.counts.list) <-
    names(unpacked.control.counts)

  # Calculate feature counts (Exclude controls)
  control.bool <-
    rownames(expression.matrix) %in% (unlist(object@Controls,
                                             use.names = FALSE))

  if (any(control.bool)) {
    endogenous.exprs.mtx <- expression.matrix[!control.bool,]
  } else {
    endogenous.exprs.mtx <- expression.matrix
    percentage.lists.counts.list <-
      lapply(percentage.lists.counts.list,
             function(x)
               ifelse(is.na(x), 0, x))
    control.transcript.counts.list <-
      lapply(control.transcript.counts.list,
             function(x)
               ifelse(is.na(x), 0, x))
  }

  total.features.counts.per.cell <-
    Matrix::colSums(endogenous.exprs.mtx !=
                      0)
  counts.per.gene <- Matrix::rowSums(expression.matrix)
  average.counts <- Matrix::rowMeans(expression.matrix)
  genes.per.cell <- Matrix::colSums(expression.matrix != 0)
  cells.per.gene <- Matrix::rowSums(expression.matrix != 0)
  mean.gene.expression <- Matrix::rowMeans(expression.matrix)

  # Calculate top gene expression
  total.expression <- sum(expression.matrix)
  sorted.counts.per.gene <- sort(counts.per.gene, decreasing = TRUE)
  top.gene.list <- names(sorted.counts.per.gene)
  top.gene.bool <- rownames(expression.matrix) %in% top.gene.list
  sorted.exprs.mtx <- expression.matrix[top.gene.bool,]
  top.genes.percentage <-
    100 * sum(sorted.counts.per.gene) / total.expression

  # Load generated values into the Metrics slot
  metrics.list <-
    list(
      TotalCounts = total.counts,
      TotalFeatureCountsPerCell = total.features.counts.per.cell,
      TotalExpression = total.expression,
      TopGeneList = top.gene.list,
      TopGenesPercentage = top.genes.percentage,
      ControlTranscriptCounts = control.transcript.counts.list,
      PercentageTotalCounts = percentage.lists.counts.list,
      AverageCounts = average.counts,
      GenesPerCell = genes.per.cell,
      CellsPerGene = cells.per.gene,
      CountsPerGene = counts.per.gene,
      MeanGeneExpression = mean.gene.expression
    )
  remove(expression.matrix)
  object@Metrics <- metrics.list
  return(object)
})

#' GetExpressionMatrix
#'
#' Returns a data frame containing the expression matrix from a \linkS4class{AEMSet} object.
#'
#' @param object A \linkS4class{AEMSet} to retrieve the expression matrix from.
#' @param format Format of the returned matrix - "data.frame" or "matrix"
#'
setGeneric(
  name = "GetExpressionMatrix",
  def = function(object, format) {
    standardGeneric("GetExpressionMatrix")
  }
)

setMethod("GetExpressionMatrix", signature("AEMSet"), function(object, format) {
  if (format == "data.frame") {
    sparse.expression.matrix <- object@ExpressionMatrix
    output <- LoadDataFrame(sparse.expression.matrix)
  } else if (format == "matrix") {
    sparse.expression.matrix <- object@ExpressionMatrix
    output <- as.matrix(sparse.expression.matrix)
  } else{
    stop("Please choose one of the following: data.frame, matrix")
  }
  return(output)
})

# Define GeneAnnotation Information - in case user changes their mind.

#' GetControls
#'
#' Retrieve list of controls from \linkS4class{AEMSet}.
#'
#' @param object An \linkS4class{AEMSet} object.
#'
setGeneric(
  name = "GetControls",
  def = function(object) {
    standardGeneric("GetControls")
  }
)

setMethod("GetControls", signature("AEMSet"), function(object) {
  control.list <- object@Controls
  return(control.list)
})

#' UpdateControls
#'
#' Replaces the control list in a \linkS4class{AEMSet} object with a new control list. This also recalculates the metrics associated with the \linkS4class{AEMSet} object.
#' For best results, define your controls before you attempt any filtering.
#'
#' @param object An \linkS4class{AEMSet} object.
#' @param gene.list A named list containing the gene identifiers. These identifiers must match the identifiers used in the expression matrix.
#'
setGeneric(
  name = "UpdateControls",
  def = function(object, gene.list) {
    standardGeneric("UpdateControls")
  }
)

setMethod("UpdateControls", signature("AEMSet"), function(object, gene.list) {
  errors <- character()
  if (length(gene.list) > 0) {
    check.controls <-
      unlist(gene.list) %in% rownames(object@ExpressionMatrix)
    if (!TRUE %in% check.controls) {
      msg <-
        "Please make sure the gene identifiers you have listed in your control list matches those used in the expression matrix."
      errors <- c(errors, msg)
    }
  } else {
    msg <- "Please make sure that you have defined a control."
    errors <- c(errors, msg)
  }

  if (length(errors) > 0) {
    errors
  } else {
    object@Controls <- gene.list
    updated.object <- GenerateMetrics(object)
    return(updated.object)
  }
})

#' GetBatchInformation
#'
#' Retrieve batch information from an \linkS4class{AEMSet}.
#'
setGeneric(
  name = "GetBatchInfo",
  def = function(object) {
    standardGeneric("GetBatchInfo")
  }
)

setMethod("GetBatchInfo", signature("AEMSet"), function(object) {
  return(object@BatchInformation)
})

#' UpdateBatchInfo
#'
#' Can be called by the user or by a filtering function. Updates Batch Information in a \linkS4class{AEMSet} object, removing cells that have been filtered out.
#'
setGeneric(
  name = "UpdateBatchInfo",
  def = function(object) {
    standardGeneric("UpdateBatchInfo")
  }
)

setMethod("UpdateBatchInfo", signature("AEMSet"), function(object) {
  # Get present list of barcodes
  present.barcodes <- colnames(object@ExpressionMatrix)

  # Get present barcode list
  current.barcode.list <- object@BatchInformation
  updated.barcode.list <-
    current.barcode.list[names(current.barcode.list) %in%
                           present.barcodes]

  # Update the object
  object@BatchInformation <- updated.barcode.list
  return(object)
})

#' GetGeneAnnotation
#'
#' Retrieve gene annotation information from an \linkS4class{AEMSet} object.
#' @param object A \linkS4class{AEMSet} object.
#'
setGeneric(
  name = "GetGeneAnnotation",
  def = function(object) {
    standardGeneric("GetGeneAnnotation")
  }
)

setMethod("GetGeneAnnotation", signature("AEMSet"), function(object) {
  gene.annotation <- object@GeneAnnotation
  return(gene.annotation)
})

#' ConvertGeneAnnotation
#'
#' Convert gene identifiers used in this \linkS4class{AEMSet} to identifiers used in another column of a dataframe stored in the GeneAnnotation slot.
#'
#' @param object A \linkS4class{AEMSet} object.
#' @param old.annotation Name of the column containing the current gene annotations.
#' @param new.annotation Name of the column you would like to convert the gene annotations to.
#'
setGeneric(
  name = "ConvertGeneAnnotation",
  def = function(object, old.annotation,
                 new.annotation) {
    standardGeneric("ConvertGeneAnnotation")
  }
)

setMethod("ConvertGeneAnnotation", signature("AEMSet"), function(object) {
  # Get currently-used gene identifiers Load Gene Annotation
  gene.annotation <- object@GeneAnnotation

  ## From expression matrix
  present.rownames <- rownames(object@ExpressionMatrix)

  ## From control lists
  control.list <- object@Controls

  # Retrieve new values
  new.identifiers <-
    gene.annotation[gene.annotation[old.annotation] == present.rownames,][, new.annotation]

  ## Rename expression matrix
  rownames(object@ExpressionMatrix) <- new.identifiers

  # Convert control list
  updated.control.list <-
    gene.annotation[, new.annotation][which(gene.annotation[, old.annotation] %in% control.list$Mt)]
  object@Controls <- updated.control.list

  return(object)
})

#' ReplaceExpressionMatrix
#'
#' Replace the expression matrix in a \linkS4class{AEMSet} with a new expression matrix and re-calculate its metrics.
#'
#' @param x Expression matrix in matrix or data.frame
#' @param object The \linkS4class{AEMSet} you would like to update
#'
setGeneric(
  name = "ReplaceExpressionMatrix",
  def = function(x, object) {
    standardGeneric("ReplaceExpressionMatrix")
  }
)

setMethod("ReplaceExpressionMatrix", signature("matrix", "AEMSet"), function(x, object) {
  object@ExpressionMatrix <- LoadSparseMatrix(x)
  updated.sea.set <- GenerateMetrics(object)
  return(updated.sea.set)
})

#' GetClusters
#'
#' @param object An \linkS4class{AEMSet} that has undergone clustering.
#'
setGeneric(
  name = "GetClusters",
  def = function(object) {
    standardGeneric("GetClusters")
  }
)

setMethod("GetClusters", signature("AEMSet"), function(object) {
  if (length(object@Clusters) == 0) {
    stop("Please run FindOptimalClusters before using this function.")
  }
  return(object@Clusters$Clusters)
})

#' SubsetBatch
#'
#' Subset a specific batch from a \linkS4class{AEMSet} object.
#'
#' @param object A \linkS4class{AEMSet} object
#' @param x Name or number of the batch you would like to subset.
#'
setGeneric(
  name = "SubsetBatch",
  def = function(object, x) {
    standardGeneric("SubsetBatch")
  }
)

setMethod("SubsetBatch", signature("AEMSet", "numeric"), function(object, x) {
  # Stop the function if batch id is not present in the dataset.
  if (!any(object@BatchInformation == as.character(x))) {
    stop("Please ensure the batch ID you have selected is present in your dataset.")
  }

  # Create a new object to output, ensures original object does not get
  # overwritten.
  subset.obj <- object

  # Retrieve cells that belong to this batch from the AEMSet obejct
  batch.list <-
    object@BatchInformation[which(object@BatchInformation == as.character(x))]
  barcode.list <- names(batch.list)

  # Other information will be extracted if they exist
  if (!is.null(object@PCA$PCA)) {
    subset.obj@PCA$PCA <- object@PCA$PCA[barcode.list,]
  }

  if (!is.null(object@PCA$ReducedPCA)) {
    subset.obj@PCA$ReducedPCA <- object@PCA$ReducedPCA[barcode.list,]
  }

  if (!is.null(object@Clusters$DistanceMatrix)) {
    distance.matrix <-
      as.matrix(object@Clusters$DistanceMatrix)[barcode.list,
                                                barcode.list]
    subset.obj@Clusters$DistanceMatrix <- as.dist(distance.matrix)
  }

  if (!is.null(object@Clusters$PutativeClusters)) {
    subset.obj@Clusters$PutativeClusters <-
      object@Clusters$PutativeClusters[barcode.list]
  }

  if (!is.null(object@Clusters$Clusters)) {
    subset.obj@Clusters$Clusters <-
      object@Clusters$Clusters[barcode.list]
    subset.obj@Clusters$NumberOfClusters <-
      length(unique(subset.obj@Clusters$Clusters))
  }

  subset.obj@ExpressionMatrix <-
    object@ExpressionMatrix[, barcode.list]
  subset.obj@BatchInformation <- batch.list
  subset.obj <- GenerateMetrics(subset.obj)
  subset.obj@Log <- c(subset.obj@Log, list(SubsetByCluster = TRUE))
  return(subset.obj)
})

#' SubsetCluster
#'
#' Subset a \linkS4class{AEMSet} object by cluster. Please make sure you have clustered with \code{\link{FindOptimalClusters}} before using this function.
#'
#' @param object A \linkS4class{AEMSet} object
#' @param x Number of the cluster you would like to subset
#'
setGeneric(
  name = "SubsetCluster",
  def = function(object, x) {
    standardGeneric("SubsetCluster")
  }
)

setMethod("SubsetCluster", signature("AEMSet", "numeric"), function(object, x) {
  # Stop the function if cluster id is not present in the dataset.
  if (!any(object@Clusters$Clusters == as.character(x))) {
    stop("Please ensure the cluster ID you have selected is present in your dataset.")
  }

  # Create a new object to output, ensures original object does not get
  # overwritten.
  subset.obj <- object

  # Retrieve cells that belong to this batch from the AEMSet obejct
  cluster.list <-
    object@Clusters$Clusters[which(object@Clusters$Clusters ==
                                     as.character(x))]
  barcode.list <- names(cluster.list)

  # Other information will be extracted if they exist
  subset.obj@PCA$PCA <- object@PCA$PCA[barcode.list,]
  subset.obj@PCA$ReducedPCA <- object@PCA$ReducedPCA[barcode.list,]
  distance.matrix <-
    as.matrix(object@Clusters$DistanceMatrix)[barcode.list,
                                              barcode.list]
  subset.obj@Clusters$DistanceMatrix <- as.dist(distance.matrix)
  subset.obj@Clusters$PutativeClusters <-
    object@Clusters$PutativeClusters[barcode.list]
  subset.obj@Clusters$Clusters <- cluster.list
  subset.obj@Clusters$NumberOfClusters <- 1

  subset.obj@ExpressionMatrix <-
    object@ExpressionMatrix[, barcode.list]
  subset.obj <- GenerateMetrics(subset.obj)
  subset.obj@Log <- c(subset.obj@Log, list(SubsetByCluster = TRUE))
  return(subset.obj)
})

#' DisplayLog
#'
#' Print out log from an \linkS4class{AEMSet}.
#'
setGeneric(
  name = "DisplayLog",
  def = function(object) {
    standardGeneric("DisplayLog")
  }
)

setMethod("DisplayLog", signature("AEMSet"), function(object){
  log <- object@Log
  print(log)
})
