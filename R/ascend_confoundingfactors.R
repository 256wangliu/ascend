#' regressGene
#'
#' Called by regressConfoundingFactors. This step extracts residuals from the 
#' supplied gene.
#' 
#' @param x Gene to regress residuals from.
#' @param covariate.matrix Covariate matrix generated by removeConfoundingFactors.
#' @param expression.matrix A transposed expression matrix generated by 
#' removeConfoundingFactors.
#' 
#' @return List of values generated from regression
#' @importFrom stats as.formula formula lm
#' 
regressGene <- function(x, covariate.matrix = NULL, expression.matrix = NULL) {
  regress_matrix <- cbind(covariate.matrix, expression.matrix[, x])
  
  # Edit string because '-' and other mathematical symbols may interfere with the formula step that is next
  colnames(regress_matrix) <- c(gsub("\\-", "_", colnames(covariate.matrix)), "GENE")
  regress_matrix <- as.data.frame(as.matrix(regress_matrix))
  
  # Generates a formula for calling the columns for input into the linear regression step
  fmla <- stats::as.formula(paste("GENE ", " ~ ", paste(gsub("\\-", "_", colnames(covariate.matrix)), collapse = "+"), sep = ""))
  
  # Linear model then extracts residuals from that result
  resid_gene <- stats::lm(fmla, data = regress_matrix)$residuals
  resid_gene <- as.data.frame(resid_gene)
  names(resid_gene) <- x
  
  # Populates the results into data.resid as a matrix
  return(resid_gene)
}

#' regressConfoundingFactors
#'
#' This function generates a scaled regression matrix based on candidate genes
#' supplied by the user. This function should be used after normalisation.
#'  
#' @param object An \code{\linkS4class{EMSet}} that has been normalised.
#' @param candidate.genes A list of genes you wish to regress from the dataset.
#' Refer to the vignette on how to choose genes for regression.
#' 
#' @return An \code{\linkS4class{EMSet}} with confounding factors regressed from the
#' expression values.
#' 
#' @examples
#' \dontrun{
#' # Define genes to regress
#' confoundingGenes <- c("CDK4","CCND1","NOC2L","ATAD3C", "CCNL2")
#' regressedSet <- regressConfoundingFactors(EMSet, 
#' candidate.genes = confoundingGenes)
#' }
#' 
#' @importFrom Matrix t
#' @importFrom BiocParallel bplapply
#' @importFrom data.table as.data.table
#' @export
#'
regressConfoundingFactors <- function(object, candidate.genes = c()) {
  
  if (!(length(candidate.genes) > 0)) {
    stop("Please supply a list of gene candidates.")
  }
  
  if (class(object) != "EMSet" ){
    stop("Please supply an EMSet.")
  }
  
  # Get the normalised matrix then transpose
  expression_matrix <- SingleCellExperiment::normcounts(object)
  cell_barcodes <- colnames(expression_matrix)
  gene_ids <- rownames(expression_matrix)
  
  transposed_matrix <- Matrix::t(expression_matrix)
  expression_matrix <- as.data.frame(transposed_matrix)
  
  # Different cases - make matches case-agnostic
  gene_vector <- unlist(lapply(candidate.genes, 
                               function(x) grep(x, gene_ids, 
                                                ignore.case = TRUE, value = TRUE)))
  
  ## Check 2 - In case there are no matches
  if (length(gene_vector) == 0) {
    stop("The genes you have supplied in your candidate gene list are not present. Please revise your list.")
  }
  
  # Create a matrix of covariate (each cell in a row)
  covariate_matrix <- expression_matrix[, gene_vector]
  covariate_matrix <- as.data.frame(covariate_matrix)
  
  # Parallel Process - Looping the regression through every gene
  # Regression can be done for all genes present in the matrix or a subset of genes
  print("Regressing gene...")
  data_resid <- BiocParallel::bplapply(gene_ids, 
                                       regressGene, 
                                       covariate.matrix = covariate_matrix, 
                                       expression.matrix = expression_matrix)
  
  # Rename the columns in the resulting matrix to their corresponding genes
  print("Regression complete. Filtering out results...")
  names(data_resid) <- colnames(expression_matrix)
  data_resid <- do.call("cbind", data_resid)
  data_resid <- as.data.frame(data_resid)
  
  # Scale the data and filter out columns with NA values
  scaled_resids <- scale(data_resid, center = TRUE, scale = TRUE)
  
  # Filter out columns with NA values
  scaled_resids_table <- data.table::as.data.table(scaled_resids)
  filtered_table <- scaled_resids_table[, 
                                        which(unlist(lapply(scaled_resids_table, 
                                                            function(x) !all(is.na(x))))), 
                                        with = FALSE]
  filtered_table <- as.data.frame(t(filtered_table))
  
  # Replace cell barcodes
  colnames(filtered_table) <- cell_barcodes
  
  # Replace negative values with 0
  filtered_table[filtered_table < 0 ] <- 0
  
  # Reorganised EMSet to accomodate regressed normalised counts
  regressed_object <- object[rownames(filtered_table), colnames(filtered_table)]
  SingleCellExperiment::normcounts(regressed_object) <- as.matrix(filtered_table)
  
  # Record in log
  log <- progressLog(regressed_object)
  log$regressConfoundingFactors <- list(candidate.genes = candidate.genes, regressed = TRUE)
  progressLog(regressed_object) <- log
  
  return(regressed_object)
}
