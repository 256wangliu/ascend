GetNodeInfo <- function(x, count.table){
  if (is.leaf(x)){
    att.obj <- attributes(x)
    nleaves <- att.obj$x.member
    branch.name <- att.obj$label

    #cluster.name <- cluster.df$cluster.list[which(cluster.df$Freq == nleaves)]
    return(nleaves)
  }
}

#' PlotDendrogram
#'
#' @param object An \linkS4class{AEMSet} that has undergone clustering
#'
PlotDendrogram <- function(object){
  # Input Checks
  if(class(object) == "AEMSet"){
    if(is.null(object@Clusters$Hclust)){
      stop("Please make sure you have run FindOptimalClusters on this AEMSet object before using this function.")
    }
  } else{
    stop("Please supply a AEMSet object to this function.")
  }

  # Extract required values from the object
  hclust.obj <- object@Clusters$Hclust
  optimal.height <- object@Clusters$OptimalTreeHeight
  nclusters <- object@Clusters$NumberOfClusters
  cluster.list <- object@Clusters$Clusters
  
  # Count table
  cluster.df <- as.data.frame(table(cluster.list))

  # Calculate cut height and cut dendrogram
  hclust.obj$labels <- rep("", length(hclust.obj$labels))
  dendro.obj <- as.dendrogram(hclust.obj)
  
  # Sort clusters by order in dendrogram
  ordered.clusters <- cluster.list[stats::order.dendrogram(dendro.obj)]
  # Sort cluster sizes in same order.
  dendro.labels <- cluster.df$Freq[unique(ordered.clusters)]
  
  # Apply labels directly to dendrogram  
  coloured.dendro <- dendextend::color_branches(dendro.obj, k = nclusters, groupLabels = dendro.labels)
  
  # Add coloured bars
  plot(coloured.dendro)
  dendro.colours <- unique(dendextend::get_leaves_branches_col(coloured.dendro))
  coloured.order <- stats::order.dendrogram(coloured.dendro)
  sorted.levels <- dendextend::sort_levels_values(as.vector(cluster.list)[coloured.order])
  sorted.levels <- sorted.levels[match(seq_along(coloured.order), coloured.order)]
  dendextend::colored_bars(dendro.colours[sorted.levels], coloured.dendro, rowLabels = "Cluster")
}

#' PlotStability
#'
#' Plots Stability, Consecutive RI and Rand Index.
#'
#' @param object An \linkS4class{AEMSet} object that has undergone clustering
#'
PlotStability <- function(object){
  # User can supply a AEMSet or data frame with rand results to this function
  if(class(object) == "AEMSet"){
    if (is.null(object@Clusters$RandMatrix)){
      stop("Please make sure you have run FindOptimalClusters on this AEMSet object before running this function.")
    }
    rand.idx.matrix <- object@Clusters$RandMatrix
  } else {
    if(!is.data.frame(object)){
      stop("Please supply a data frame.")
    }
    # Matrix must have the following column headers
    rand.colnames <- c("cluster.index.consec", "cluster.index.ref", "order", "stability_count", "cluster_count")
    if (!all.equal(rand.colnames, colnames(object@Clusters$RandMatrix))){
      stop("Please use the rand index matrix generated by FindOptimalClusters for this function.")
    }
    rand.idx.matrix <- object
  }

  rand.idx.matrix$stability_count <- rand.idx.matrix$stability_count/40
  key.stats.df <- as.data.frame(cbind(as.numeric(rand.idx.matrix$order)*0.025, rand.idx.matrix$stability_count, rand.idx.matrix$cluster.index.ref, rand.idx.matrix$cluster.index.consec, rand.idx.matrix$cluster_count/10))
  colnames(key.stats.df) <-c('Height', 'Stability', 'RandIndex', 'ConsecutiveRI', 'ClusterCount/10')

  key.stats.df$Height <-as.character(key.stats.df$Height)
  key.stats.tidy <- reshape2::melt(key.stats.df, id='Height')
  key.stats.tidy$Height <-as.numeric(key.stats.tidy$Height)

  diagnostic.plot <- ggplot2::ggplot(key.stats.tidy)
  diagnostic.plot <- diagnostic.plot + ggplot2::geom_line(ggplot2::aes(x=Height, y=value,  colour=variable)) + ggplot2::theme_bw() + ggplot2::theme(axis.text = ggplot2::element_text(size=18), axis.title = ggplot2::element_text(size=18))+ ggplot2::theme(legend.text = ggplot2::element_text(size=18)) + ggplot2::theme(legend.title = ggplot2::element_blank()) + ggplot2::xlab('Parameter from 0.025 to 1') + ggplot2::ylab('Scores')

  return(diagnostic.plot)
}

PlotClusterDendro <- function (dendro, colors, groupLabels = NULL, rowText = NULL,
                               rowTextAlignment = c("left", "center", "right"), rowTextIgnore = NULL,
                               textPositions = NULL, setLayout = TRUE, autoColorHeight = TRUE,
                               colorHeight = 0.2, rowWidths = NULL, dendroLabels = NULL,
                               addGuide = FALSE, guideAll = FALSE, guideCount = 50, guideHang = 0.2,
                               addTextGuide = FALSE, cex.colorLabels = 0.8, cex.dendroLabels = 0.9,
                               cex.rowText = 0.8, marAll = c(1, 5, 3, 1), saveMar = TRUE,
                               abHeight = NULL, abCol = "red", ...)
{
  #dendro <- object@Clusters$HClust
  #colors <- object@Clusters$ClusteringMatrix
  dendro$labels <- rep('', length(dendro$labels))

  oldMar = par("mar")
  if (!is.null(dim(colors))) {
    nRows = dim(colors)[2]
  }
  else nRows = 1
  if (!is.null(rowText))
    nRows = nRows + if (is.null(textPositions))
      nRows
  else length(textPositions)
  if (autoColorHeight)
    colorHeight = 0.2 + 0.3 * (1 - exp(-(nRows - 1)/6))
  if (setLayout)
    layout(matrix(c(1:2), 2, 1), heights = c(1 - colorHeight,
                                             colorHeight))
  par(mar = c(0, marAll[2], marAll[3], marAll[4]))
  plot(dendro, labels = dendroLabels, cex = cex.dendroLabels,
       ...)
  if (addGuide)
    addGuideLines(dendro, count = if (guideAll)
      length(dendro$height) + 1
      else guideCount, hang = guideHang)
  if (!is.null(abHeight))
    abline(h = abHeight, col = abCol)
  par(mar = c(marAll[1], marAll[2], 0, marAll[4]))
  PlotConsensusBars(dendro, colors, groupLabels, cex.rowLabels = cex.colorLabels,
                    rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    cex.rowText = cex.rowText, rowWidths = rowWidths, addTextGuide = addTextGuide)
  if (saveMar)
    par(mar = oldMar)
}
#--------------plotColorUnderTree--------------#
PlotConsensusBars <- function (dendro, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, ...) {
  PlotOrderedColors(dendro$order, colors = colors, rowLabels = rowLabels,
                    rowWidths = rowWidths, rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    addTextGuide = addTextGuide, cex.rowLabels = cex.rowLabels,
                    cex.rowText = cex.rowText, startAt = 0, ...)
}
#--------------plotOrderedColors--------------#
PlotOrderedColors <- function (order, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, startAt = 0, ...) {
  colors = as.matrix(colors)
  dimC = dim(colors)
  if (is.null(rowLabels) & (length(dimnames(colors)[[2]]) ==
                            dimC[2]))
    rowLabels = colnames(colors)
  sAF = options("stringsAsFactors")
  options(stringsAsFactors = FALSE)
  on.exit(options(stringsAsFactors = sAF[[1]]), TRUE)
  nColorRows = dimC[2]
  if (length(order) != dimC[1])
    stop("ERROR: length of colors vector not compatible with number of objects in 'order'.")
  C = colors[order, , drop = FALSE]
  step = 1/(dimC[1] - 1 + 2 * startAt)
  barplot(height = 1, col = "white", border = FALSE, space = 0,
          axes = FALSE)
  charWidth = strwidth("W")/2
  if (!is.null(rowText)) {
    if (is.null(textPositions))
      textPositions = c(1:nColorRows)
    if (is.logical(textPositions))
      textPositions = c(1:nColorRows)[textPositions]
    nTextRows = length(textPositions)
  }
  else nTextRows = 0
  nRows = nColorRows + nTextRows
  ystep = 1/nRows
  if (is.null(rowWidths)) {
    rowWidths = rep(ystep, nColorRows + nTextRows)
  }
  else {
    if (length(rowWidths) != nRows)
      stop("plotOrderedColors: Length of 'rowWidths' must equal the total number of rows.")
    rowWidths = rowWidths/sum(rowWidths)
  }
  hasText = rep(0, nColorRows)
  hasText[textPositions] = 1
  csPosition = cumsum(c(0, hasText[-nColorRows]))
  colorRows = c(1:nColorRows) + csPosition
  rowType = rep(2, nRows)
  rowType[colorRows] = 1
  physicalTextRow = c(1:nRows)[rowType == 2]
  yBottom = c(0, cumsum(rowWidths[nRows:1]))
  yTop = cumsum(rowWidths[nRows:1])
  if (!is.null(rowText)) {
    rowTextAlignment = match.arg(rowTextAlignment)
    rowText = as.matrix(rowText)
    textPos = list()
    textPosY = list()
    textLevs = list()
    for (tr in 1:nTextRows) {
      charHeight = max(strheight(rowText[, tr], cex = cex.rowText))
      width1 = rowWidths[physicalTextRow[tr]]
      nCharFit = floor(width1/charHeight/1.7/par("lheight"))
      if (nCharFit < 1)
        stop("Rows are too narrow to fit text. Consider decreasing cex.rowText.")
      set = textPositions[tr]
      textLevs[[tr]] = sort(unique(rowText[, tr]))
      textLevs[[tr]] = textLevs[[tr]][!textLevs[[tr]] %in%
                                        rowTextIgnore]
      nLevs = length(textLevs[[tr]])
      textPos[[tr]] = rep(0, nLevs)
      orderedText = rowText[order, tr]
      for (cl in 1:nLevs) {
        ind = orderedText == textLevs[[tr]][cl]
        sind = ind[-1]
        ind1 = ind[-length(ind)]
        starts = c(if (ind[1]) 1 else NULL, which(!ind1 &
                                                    sind) + 1)
        ends = which(c(ind1 & !sind, ind[length(ind)]))
        if (length(starts) == 0)
          starts = 1
        if (length(ends) == 0)
          ends = length(ind)
        if (ends[1] < starts[1])
          starts = c(1, starts)
        if (ends[length(ends)] < starts[length(starts)])
          ends = c(ends, length(ind))
        lengths = ends - starts
        long = which.max(lengths)
        textPos[[tr]][cl] = switch(rowTextAlignment,
                                   left = starts[long], center = (starts[long] +
                                                                    ends[long])/2 + 0.5, right = ends[long] +
                                     1)
      }
      if (rowTextAlignment == "left") {
        yPos = seq(from = 1, to = nCharFit, by = 1)/(nCharFit +
                                                       1)
      }
      else {
        yPos = seq(from = nCharFit, to = 1, by = -1)/(nCharFit +
                                                        1)
      }
      textPosY[[tr]] = rep(yPos, ceiling(nLevs/nCharFit) +
                             5)[1:nLevs][rank(textPos[[tr]])]
    }
  }
  jIndex = nRows
  if (is.null(rowLabels))
    rowLabels = c(1:nColorRows)
  C[is.na(C)] = "grey"
  for (j in 1:nColorRows) {
    jj = jIndex
    ind = (1:dimC[1])
    xl = (ind - 1.5 + startAt) * step
    xr = (ind - 0.5 + startAt) * step
    yb = rep(yBottom[jj], dimC[1])
    yt = rep(yTop[jj], dimC[1])
    if (is.null(dim(C))) {
      rect(xl, yb, xr, yt, col = as.character(C), border = as.character(C))
    }
    else {
      rect(xl, yb, xr, yt, col = as.character(C[, j]),
           border = as.character(C[, j]))
    }
    text(rowLabels[j], pos = 2, x = -charWidth/2 + xl[1],
         y = (yBottom[jj] + yTop[jj])/2, cex = cex.rowLabels,
         xpd = TRUE)
    textRow = match(j, textPositions)
    if (is.finite(textRow)) {
      jIndex = jIndex - 1
      xt = (textPos[[textRow]] - 1.5) * step
      xt[xt < par("usr")[1]] = par("usr")[1]
      xt[xt > par("usr")[2]] = par("usr")[2]
      yt = yBottom[jIndex] + (yTop[jIndex] - yBottom[jIndex]) *
        (textPosY[[textRow]] + 1/(2 * nCharFit + 2))
      nt = length(textLevs[[textRow]])
      if (addTextGuide)
        for (l in 1:nt) lines(c(xt[l], xt[l]), c(yt[l],
                                                 yTop[jIndex]), col = "darkgrey", lty = 3)
      textAdj = c(0, 0.5, 1)[match(rowTextAlignment, c("left",
                                                       "center", "right"))]
      text(textLevs[[textRow]], x = xt, y = yt, adj = c(textAdj,
                                                        1), xpd = TRUE, cex = cex.rowText)
    }
    jIndex = jIndex - 1
  }
  for (j in 0:(nColorRows + nTextRows)) lines(x = c(0, 1),
                                              y = c(yBottom[j + 1], yBottom[j + 1]))
}

#' PlotStabilityDendro
#'
#' @param object A \linkS4class{AEMSet} that has undergone clustering.
#'
PlotStabilityDendro <- function(object){
  # Check that the user has done the required steps.
  if (length(object@Clusters) == 0){
    stop("Please run FindOptimalClusters on this object before using this function.")
  }

  # Get the variables
  dendro <- object@Clusters$Hclust
  colours <- object@Clusters$ClusteringMatrix

  # Plotting function
  print(PlotClusterDendro(dendro, colours))
}


#' PlotMDS
#'
#' Generates a Multi-Dimensional Scaling (MDS) plot.
#'
#'  @param object An \linkS4class{AEMSet} that has undergone clustering with \code{FindOptimalClusters}.
#'  @param PCA If true, use PCA-reduced matrix to generate MDS plot
#'  @param dim1 Which dimension to plot on the x-axis
#'  @param dim2 Which dimension to plot on the y-axis
#'
PlotMDS <- function(object, PCA = TRUE, dim1 = 1, dim2 = 2, condition.list = list()){
  if (class(object) != "AEMSet"){
    stop("Please supply an AEMSet object.")
  }

  # Retrieve distance matrix
  if (PCA){
    # Stop if user hasn't run PCA.
    if (length(object@PCA) == 0){
      stop("Please use RunPCA on this object before using the PCA argument for this function.")
    }

    # Retrieve distance matrix
    if (length(object@Clusters) > 0){
      distance.matrix <- object@Clusters$DistanceMatrix
    } else{
      print("Calculating distance matrix from top 20 PCAs...")
      pca.matrix <- object@PCA$PCA[,1:20]
      distance.matrix <- stats::dist(pca.matrix)
    }
  } else{
    print("Calculating distance matrix from expression data...")
    expression.matrix <- GetExpressionMatrix(object, "matrix")
    transposed.matrix <- Matrix::t(expression.matrix)
    distance.matrix <- stats::dist(transposed.matrix)
  }

  # Scale matrix
  print("Running cmdscale...")
  mds.matrix <-stats::cmdscale(distance.matrix, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE)
  print("Cmdscale complete! Processing scaled data...")
  mds.matrix <- as.data.frame(mds.matrix)
  colnames(mds.matrix) <- c("Dim1", "Dim2")

  print("Generating MDS plot...")
  if (length(condition.list) > 0){
    mds.matrix$condition <- unlist(condition.list)
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2, col=factor(condition))) + ggplot2::geom_point()
  } else{
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2)) + ggplot2::geom_point()
  }
  return(mds.plot)
}

#' PlotTSNE
#'
#' Generates a 2D TSNE plot.
#'
#' @param object An \linkS4class{AEMSet}.
#' @param PCA Set to FALSE to not use PCA-reduced values
#' @param condition.list (Optional) A list of cell identifiers and their associated condition
#' @param seed (Optional) Set to a specific value for reproducible TSNE plots
#' @param perplexity (Optional) Numeric; perplexity parameter
#' @param theta (Optional) Nimeroc; Speed/accuracy trade-off (increase for less accuracy)
#'
PlotTSNE <- function(object, PCA = TRUE, condition.list = list(), seed = 0, perplexity = 30, theta = 0.5){
  # Input checks
  if (class(object) != "AEMSet"){
    stop("Please supply an AEMSet to this function.")
  }

  if(PCA){
    if (!(length(object@PCA) > 0)){
      stop("Please reduce this dataset with RunPCA before using this function.")
    } else{
      pca.barcodes <- rownames(object@PCA$ReducedPCA)
      condition.list <- condition.list[pca.barcodes]
      if (!(length(condition.list) > 0)){
        stop("Please ensure all cell identifiers specified in the condition list are in the AEMSet.")
      }
    }
  } else{
    if (!all(names(condition.list) %in% object@ExpressionMatrix)){
      stop("Please ensure all cell identifiers specified in the condition list are in the AEMSet.")
    }
  }

  # Run TSNE in 2D
  tsne.df<- RunTSNE(object, PCA = PCA, dimensions = 2, seed = seed, perplexity = perplexity, theta = theta)

  # Generate Plots
  if (length(condition.list) > 0){
    tsne.df$conditions <- as.factor(unlist(condition.list))
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)))
  } else{
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point()
  }

  # Store TSNE matrix and plot in TSNE slot
  output <- list(TSNE = tsne.df, Plot = tsne.plot, Seed = seed)
  return(output)
}

#' PlotPCA
#'
#' Plot two principal components (PCs) on a scatter plot.
#'
#' @param object An \linkS4class{AEMSet} object that has undergone PCA
#' @param dim1 Principal component to plot on the x-axis
#' @param dim2 Principal component to plot on the y-axis
#' @param condition.list (Optional) A list of barcodes and associated conditions to colour points by
#'
PlotPCA <- function(object, dim1 = 1, dim2 = 2, condition.list = list()){
  # Check if PCA has been run
  if(length(object@PCA) == 0){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  # Extract dimensions to plot
  pca.matrix <- object@PCA$PCA
  plot.matrix <- pca.matrix[,c(dim1, dim2)]
  colnames(plot.matrix) <- c("x", "y")

  if (length(condition.list) > 0){
    plot.matrix$conditions <- as.factor(unlist(condition.list))
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)))
  } else{
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point()
  }

  return(pca.plot)
}

#' PlotPCAVariance
#'
#' Plots PCA Percent Variance.
#'
#' @param object An \linkS4class{AEMSet} that has undergone PCA.
#' @param n Number of PCA values on the plot
#'
PlotPCAVariance <- function(object, n){
  if(is.null(object@PCA$PCAPercentVariance)){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  pca.obj <- ggplot2::qplot(y=object@PCA$PCAPercentVariance[1:n], x=1:n, geom="line", xlab="Principal Component (PC)", ylab="% Variance", main="Percent Variance per PC")
  return(pca.obj)

}

#' PlotNormalisationQC
#'
#' Generates a series of plots comparing an un-normalised and a normalised \linkS4class{AEMSet}.
#'
#' @param original An un-normalised \linkS4class{AEMSet}
#' @param normalised A normalised \linkS4class{AEMSet}
#' @param gene Gene to plot expression levels for (optional)
#'
PlotNormalisationQC <- function(original = NULL, normalised = NULL, gene = NULL) {
  # Insert Check For Normalisation
  if(!is.null(original@Log$NormalisationMethod)){
    stop("Please supply an un-normalised AEMSet object.")
  }

  if(is.null(normalised@Log$NormalisationMethod)){
    stop("Please supply a normalised AEMSet object.")
  }

  # Set output
  output.list <- list()

  # Get metrics we need from old and new object
  print("Retrieving data from AEMSets...")
  libsize.original <- original@Metrics$TotalCounts
  libsize.normalised <- normalised@Metrics$TotalCounts

  # Get libsize with cells that are in normalised from original
  libsize.original.2 <- libsize.original[which(names(libsize.original) %in% names(libsize.normalised))]

  # Get Expression Matrices
  matrix.original <- GetExpressionMatrix(original, "data.frame")
  matrix.normalised <- GetExpressionMatrix(normalised, "data.frame")

  # If normalised by scater, unlog results
  if(normalised@Log$NormalisationMethod == "scranNormalise"){
    matrix.normalised <- as.data.frame(UnLog2Matrix(matrix.normalised))
    libsize.normalised <- colSums(matrix.normalised)
  }

  # Generate histogram
  print("Plotting libsize histograms...")
  libsize.plot.original <- ggplot2::qplot(libsize.original, main='Before normalisation', ylab='Total reads per cell', xlab='Cells')
  libsize.plot.normalised <- ggplot2::qplot(libsize.normalised, main='After normalisation', ylab='Total reads per cell', xlab='Cells')

  # Remove zero counts
  matrix.original <- matrix.original[which(rowSums(matrix.original) > 0),]
  matrix.normalised <- matrix.normalised[which(rowSums(matrix.normalised) > 0),]

  # Plot scatter for GAPDH
  gapdh <- rownames(matrix.normalised)[which("GAPDH" == toupper(rownames(matrix.normalised)))]
  if(length(gapdh) > 0){
    print("Plotting GAPDH expression...")
    gapdh.counts.1 <- matrix.original[gapdh,][which(matrix.original[gapdh, ] > 0)]
    gapdh.counts.2 <- matrix.normalised[gapdh,][which(matrix.normalised[gapdh, ] > 0)]
    gapdh.scatter.1 <- ggplot2::qplot(x = 1:length(gapdh.counts.1), y = unlist(gapdh.counts.1), geom="point", alpha=0.2, main='Expression of GAPDH (Before normalisation)', xlab="Cells" , ylab="Gene expression")
    gapdh.scatter.2 <- ggplot2::qplot(x = 1:length(gapdh.counts.2), y = unlist(gapdh.counts.2), geom="point", alpha=0.2, main='Expression of GAPDH (After normalisation)', xlab="Cells", ylab="Gene expression")
    output.list <- c(output.list, GAPDHScatter = list(Original = gapdh.scatter.1, Normalised = gapdh.scatter.2))
  }

  # Plot scatter for a random gene
  # This while loop ensures a gene is selected where there are at least ten cells with expression over zero
  if (missing(gene)){
    success <- FALSE
    while (!success){
      gene <- sample(rownames(matrix.normalised), 1)
      gene.original <- matrix.original[gene,][which(matrix.original[gene, ] > 0)]
      gene.normalised <- matrix.normalised[gene,][which(matrix.normalised[gene, ] > 0)]
      success <- (length(gene.original) > 10) && (length(gene.normalised) > 10)
    }
  } else {
    gene.original <- matrix.original[gene,][which(matrix.original[gene, ] > 0)]
    gene.normalised <- matrix.normalised[gene,][which(matrix.normalised[gene, ] > 0)]
  }

  print(sprintf("Plotting %s expression...", gene))
  original.scatter <- ggplot2::qplot(x = 1:length(gene.original), y = unlist(gene.original), geom="point", alpha=0.2, main = sprintf("Expression of %s (Before normalisation", gene), xlab="Cells" , ylab="Gene expression")
  normalised.scatter <- ggplot2::qplot(x = 1:length(gene.normalised), y = unlist(gene.normalised), geom="point", alpha=0.2, main = sprintf("Expression of %s (After normalisation", gene), xlab="Cells" , ylab="Gene expression")

  # Generate box plots
  print("Plotting gene expression box plots...")
  ordered1 <- matrix.original[order(rowSums(matrix.original), decreasing=T),]
  ordered2 <- matrix.normalised[order(rowSums(matrix.normalised), decreasing=T),]

  ordered1 <- stack(ordered1[,1:100])
  ordered2 <- stack(ordered2[,1:100])

  original.boxplot <- ggplot2::ggplot(ordered1, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot()
  normalised.boxplot <- ggplot2::ggplot(ordered2, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot()

  original.boxplot <- original.boxplot + ggplot2::labs(title='Before normalisation',  y='Gene expression', x='Cells')
  normalised.boxplot <- normalised.boxplot + ggplot2::labs(title='After normalisation',  y='Gene expression', x='Cells')

  original.boxplot <- original.boxplot + ggplot2::theme(axis.text.x = ggplot2::element_blank())
  normalised.boxplot <- normalised.boxplot + ggplot2::theme(axis.text.x = ggplot2::element_blank())

  print("Plots complete!")
  # Return a list of output
  output.list <- c(output.list, list(
    LibSizeHistograms = list(Original = libsize.plot.original, Normalised = libsize.plot.normalised),
    RandomGeneScatter = list(Original = original.scatter, Normalised = normalised.scatter),
    GeneExpressionBoxplot = list(Original = original.boxplot, Normalised = normalised.boxplot)
  ))

  return(output.list)
}


# From perceptions - https://github.com/zonination/perceptions
# Generate the colors for the chart procedurally with RColorBrewer
z_theme <- function() {
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[2]
  color.grid.major = palette[5]
  color.axis.text = palette[7]
  color.axis.title = palette[7]
  color.title = palette[8]
  # Begin construction of chart
  ggplot2::theme_bw(base_size=9) +
    # Set the entire chart region to a light gray color
    ggplot2::theme(panel.background = ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(plot.background= ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(panel.border= ggplot2::element_rect(color=color.background)) +
    # Format the grid
    ggplot2::theme(panel.grid.major= ggplot2::element_line(color=color.grid.major,size=.25)) +
    ggplot2::theme(panel.grid.minor= ggplot2::element_blank()) +
    ggplot2::theme(axis.ticks= ggplot2::element_blank()) +
    # Format the legend, but hide by default
    ggplot2::theme(legend.position="none") +
    ggplot2::theme(legend.background = ggplot2::element_rect(fill=color.background)) +
    ggplot2::theme(legend.text = ggplot2::element_text(size=7,color=color.axis.title)) +
    # Set title and axis labels, and format these and tick marks
    ggplot2::theme(plot.title = ggplot2::element_text(color=color.title, size=20, vjust=1.25)) +
    ggplot2::theme(axis.text.x = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.text.y = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.title.x = ggplot2::element_text(size=16, color=color.axis.title, vjust=0)) +
    ggplot2::theme(axis.title.y = ggplot2::element_text(size=16, color=color.axis.title, vjust=1.25))
}

#' PlotTopGenesPerSample
#'
#' Generates a violin-beeswarm plot of top genes per sample.
#'
#' @param An \linkS4class{AEMSet} object
#'
PlotTopGenesPerSample <- function(object){
  # Generate tidy data
  sparse.matrix <- object@ExpressionMatrix
  expression.matrix <- LoadDataFrame(sparse.matrix)
  remove(sparse.matrix)

  present.barcodes <- colnames(expression.matrix)
  top.gene.list <- object@Metrics$TopGeneList
  metrics <- object@Metrics

  present.batches <- unlist(object@BatchInformation[present.barcodes])
  batch.names <- unique(present.batches)

  # Prepare Top 500
  top.500.gene.list <- top.gene.list[1:500]
  subset.500.mtx <- expression.matrix[top.500.gene.list,]
  top.500.percentage <- 100 * colSums(subset.500.mtx)/colSums(expression.matrix)

  # Prepare Top 100
  top.100.gene.list <- top.gene.list[1:100]
  subset.100.mtx <- expression.matrix[top.100.gene.list,]
  top.100.percentage <- 100 * colSums(subset.100.mtx)/colSums(expression.matrix)

  ## Tidy dataframe
  combined.data <- list(Percentage500 = top.500.percentage, Percentage100 = top.100.percentage, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentage500, colour = Percentage100))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotLibrarySizesPerSample
#'
#' Generates a violin-beeswarm plot of library sizes per sample.
#' @param object A \linkS4class{AEMSet}
#'
PlotLibrarySizesPerSample <- function(object){
  # Tidy data to feed into ggplot
  sparse.matrix <- object@ExpressionMatrix
  expression.matrix <- LoadDataFrame(sparse.matrix)
  remove(sparse.matrix)

  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(object@BatchInformation[present.barcodes])
  total.counts <- metrics$TotalCounts[present.barcodes]
  total.features <- metrics$TotalFeatureCountsPerCell[present.barcodes]
  batch.names <- unique(present.batches)

  ## Tidy dataframe
  combined.data <- list(TotalCounts = total.counts, FeatureCounts = total.features, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = TotalCounts, colour = FeatureCounts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotControlPercentagesPerSample
#'
#' @param object A \linkS4class{AEMSet} object
#' @param control.name Name of the control you would like to plot
#'
PlotControlPercentagesPerSample <- function(object, control.name){
  # Tidy data to feed into ggplot
  ## Load data from the object
  sparse.matrix <- object@ExpressionMatrix
  expression.matrix <- LoadDataFrame(sparse.matrix)
  remove(sparse.matrix)

  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(object@BatchInformation[present.barcodes])
  subset.control.percentages <- metrics$PercentageTotalCounts[[control.name]][present.barcodes]
  subset.counts <- metrics$ControlTranscriptCounts[[control.name]][present.barcodes]
  batch.names <- unique(present.batches)

  ## Combine into a tidy dataframe
  combined.data <- list(Percentages = subset.control.percentages, Counts = subset.counts, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # Use ggplot to generate a violin/beeswarm plot
  ## Colour palette
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  plot.title <- sprintf("Percentage of reads mapped to %s genes", control.name)

  ## ggplot call
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentages, colour = Counts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("% Reads")  + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(control.plot)
}


#' PlotTopGeneExpression
#'
#' Generates a boxplot using \link[ggplot2]{geom_boxplot} of the most expressed genes in the dataset, in a range defined by the user.
#' @param object A AEMSet object
#' @param n Number of genes to be plotted
#'
PlotTopGeneExpression <- function(object, n = 50, controls = TRUE){
  # Prep data to feed in
  if(!controls){
    control.list <- object@Controls
    if(names(control.list) == c("Mt", "Rb")){
      object <- ExcludeControl(object, "Mt")
      object <- ExcludeControl(object, "Rb")
    }
  }

  plot.title <- sprintf("Top %i Expressed Genes", n)
  sparse.matrix <- object@ExpressionMatrix
  expression.matrix <- LoadDataFrame(sparse.matrix)
  remove(sparse.matrix)
  counts.per.gene <- object@Metrics$CountsPerGene
  total.expression <- object@Metrics$TotalExpression
  top.gene.list <- object@Metrics$TopGeneList[1:n]

  subset.exprs.mtx <- expression.matrix[top.gene.list,]
  sorted.counts.per.gene <- sort(counts.per.gene, decreasing = TRUE)
  top.genes.percentage <- 100 * sum(sorted.counts.per.gene[1:n])/total.expression
  top.gene.expression.per.cell <- (100 * subset.exprs.mtx)/colSums(expression.matrix)

  transposed.gene.expression <- t(top.gene.expression.per.cell)
  melted.gene.expression <- reshape2::melt(as.matrix(transposed.gene.expression))
  melted.gene.expression$Var2 <- factor(melted.gene.expression$Var2, levels = (rev(top.gene.list)))
  ggplot.obj <- ggplot2::ggplot(melted.gene.expression, ggplot2::aes(y = value,x = Var2)) + ggplot2::geom_boxplot(ggplot2::aes(fill=Var2), alpha=.5, outlier.colour = NULL)
  ggplot.obj <- ggplot.obj + ggplot2::coord_flip() + z_theme() + ggplot2::xlab("Gene") + ggplot2::ylab("% Expression") + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(ggplot.obj)
}

#' PlotGeneralQC
#'
#' This function generates the following plots:
#'
#' @param object A \linkS4class{AEMSet} object
#'
PlotGeneralQC <- function(object){
  output.list <- list()
  # 1. Plot library sizes and expressed gene histograms
  print("Plotting Total Count and Library Size...")
  libsize.plot <- ggplot2::qplot(object@Metrics$TotalCounts/1e6, geom="histogram", main="Distribution of library sizes across dataset", xlab="Library sizes (millions)", ylab="Number of cells")
  feature.counts.per.cell <- ggplot2::qplot(object@Metrics$TotalFeatureCountsPerCell/1e6, geom="histogram", xlab="Number of expressed genes", main="Number of expressed genes per cell", ylab="Number of cells")
  output.list[["LibSize"]] <- libsize.plot
  output.list[["FeatureCountsPerCell"]] <- feature.counts.per.cell

  # 2. Average Counts
  print("Plotting Average Counts...")
  log10.average.gene.count <- ggplot2::qplot(log10(object@Metrics$AverageCounts), geom="histogram", main="Average Count of Genes", xlab=expression(Log[10]~"Average Count"))
  smooth.scatter <- graphics::smoothScatter(log10(object@Metrics$AverageCounts), object@Metrics$CellsPerGene, xlab=expression(Log[10]~"Average Count"),ylab="Number of expressing cells", main = "Average Expression of Genes Per Cell")
  log2.average.count <- ggplot2::qplot(log2(object@Metrics$AverageCounts), geom="histogram", xlab="Log2 number of cells expressing the gene", ylab="Number of genes", main="Number of cells a gene was detected")
  average.gene.count <- ggplot2::qplot(object@Metrics$AverageCounts, xlab="Number of cells expressing the gene", ylab="Number of genes", main="Number of cells vs detected gene was detected")

  output.list[["Log10AverageGeneCount"]] <- log10.average.gene.count
  output.list[["AverageCountSmoothScatter"]] <- smooth.scatter
  output.list[["Log2AverageGeneCount"]] <- log2.average.count
  output.list[["AverageGeneCount"]] <- average.gene.count

  # No controls breaks this section  - therefore requires check
  if (is.null(object@Log$Filtering["RemoveControls"])){
    # 2. Proportion of Controls
    print("Plotting Proportion of Control Histograms...")
    percentage.total.plots <- list()
    for (control.name in names(object@Metrics$PercentageTotalCounts)){
      xlab.string <- paste0("%", sprintf("%s proportion ", control.name))
      title.string <- sprintf("Proportion of control: %s", control.name)
      subplot <- ggplot2::qplot(unlist(object@Metrics$PercentageTotalCounts[control.name]), xlab=xlab.string, ylab="Number of cells", main=title.string)
      percentage.total.plots[[control.name]] <- subplot
    }

    # 6. Plot Controls Per Sample
    print("Using ggplot2 to plot Control Percentages...")
    percentage.sample.list <- list()
    for (control.name in names(object@Controls)){
      control.pct.plot <- PlotControlPercentagesPerSample(object, control.name)
      percentage.sample.list[[control.name]] <- control.pct.plot
    }

    output.list[["ControlPercentageTotalCounts"]] <- percentage.total.plots
    output.list[["ControlPercentageSampleCounts"]] <- percentage.sample.list
  }
  # 4. Plot Library Sizes per Sample
  print("Using ggplot2 to plot Library Sizes Per Sample...")
  library.size.plot <- PlotLibrarySizesPerSample(object)
  output.list[["LibSizePerSample"]] <- library.size.plot

  # 5. Plot Genes per Sample
  print("Using ggplot2 to plot Top Genes Per Sample...")
  genes.per.sample.plot <- PlotTopGenesPerSample(object)
  output.list[["TopGenesPerSample"]] <- genes.per.sample.plot

  # 7. Plot Top Genes
  print("Using ggplot2 to plot Top Gene Expression...")
  top.genes.plot <- PlotTopGeneExpression(object)
  output.list[["TopGenes"]] <- top.genes.plot

  return(output.list)
}
