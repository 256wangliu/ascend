#' PlotDEVolcano
#'
#' Produces a volcano plot featuring differential expression results.
#'
#' @param de.results Differential expression results generated by \code{\link{RunDifferentialExpression}} or \link{\link{RunClusterDiffExpression}}
#' @param threshold Quantile threshold to determine significant results by
#' @param labels Display names of significant results on plot
#'
PlotDEVolcano <- function(de.results, threshold = 5e-3, labels = FALSE){
  # Check data frame contains required information
  required.cols <- c("id", "padj", "log2FoldChange")
  if (!is.data.frame(de.results)){
    stop("Please supply a data frame.")
  } else{
   if(!any(required.cols %in% colnames(de.results))){
    stop("Please make sure your dataframe has the following columns: id, padj, log2FoldChange")
   }
  }

  # Convert adjusted p-values to log10
  de.results$padj <- -log10(de.results$padj)

  # Find significant limits
  padj.limit <- quantile(de.results$padj, c(5e-3, 1-5e-3))
  fc.limit <- quantile(de.results$log2FoldChange, c(5e-3, 1-5e-3))

  # Add groups to DF
  de.results$group <- rep("Normal", nrow(de.results))
  de.results[de.results$padj < padj.limit[1] | de.results$padj > padj.limit[2],]$group <- "padj"
  de.results[de.results$log2FoldChange < fc.limit[1] | de.results$log2FoldChange > fc.limit[2],]$group <- "log2FoldChange"

  # Generate volcano plot
  volcano.plot <- ggplot2::ggplot(de.results, ggplot2::aes(log2FoldChange, padj))
  volcano.plot <- volcano.plot + ggplot2::geom_point(ggplot2::aes(colour = group))
  volcano.plot <- volcano.plot + ggplot2::scale_colour_manual(name = "", values = c("Normal"="#323234", "padj"="#014abb", "log2FoldChange"="#932600"))
  volcano.plot <- volcano.plot + ggplot2::theme_bw()

  if(labels){
    volcano.plot <- volcano.plot + ggplot2::geom_text(data = subset(de.results, padj < padj.limit[1] | padj > padj.limit[2] | log2FoldChange < fc.limit[1] | log2FoldChange > fc.limit[2]), ggplot2::aes(log2FoldChange, padj, label = id))
  }
  return(volcano.plot)
}
#' PlotDendrogram
#'
#' @param object An \linkS4class{AEMSet} that has undergone clustering
#'
PlotDendrogram <- function(object){
  # Input Checks
  if(class(object) == "AEMSet"){
    if(is.null(object@Clusters$Hclust)){
      stop("Please make sure you have run FindOptimalClusters on this AEMSet object before using this function.")
    }
  } else{
    stop("Please supply a AEMSet object to this function.")
  }

  # Extract required values from the object
  hclust.obj <- object@Clusters$Hclust
  optimal.height <- object@Clusters$OptimalTreeHeight
  nclusters <- object@Clusters$NumberOfClusters
  cluster.list <- object@Clusters$Clusters

  # Count table
  cluster.df <- as.data.frame(table(cluster.list))

  # Calculate cut height and cut dendrogram
  hclust.obj$labels <- rep("", length(hclust.obj$labels))
  dendro.obj <- as.dendrogram(hclust.obj)

  # Sort clusters by order in dendrogram
  ordered.clusters <- cluster.list[stats::order.dendrogram(dendro.obj)]
  # Sort cluster sizes in same order.
  dendro.labels <- cluster.df$Freq[unique(ordered.clusters)]

  # Apply labels directly to dendrogram
  coloured.dendro <- dendextend::color_branches(dendro.obj, k = nclusters, groupLabels = dendro.labels)

  # Add coloured bars
  plot(coloured.dendro)
  dendro.colours <- unique(dendextend::get_leaves_branches_col(coloured.dendro))
  coloured.order <- stats::order.dendrogram(coloured.dendro)
  sorted.levels <- dendextend::sort_levels_values(as.vector(cluster.list)[coloured.order])
  sorted.levels <- sorted.levels[match(seq_along(coloured.order), coloured.order)]
  dendextend::colored_bars(dendro.colours[sorted.levels], coloured.dendro, rowLabels = "Cluster")
}

#' PlotStability
#'
#' Plots Stability, Consecutive RI and Rand Index.
#'
#' @param object An \linkS4class{AEMSet} object that has undergone clustering
#'
PlotStability <- function(object){
  # User can supply a AEMSet or data frame with rand results to this function
  if(class(object) == "AEMSet"){
    if (is.null(object@Clusters$RandMatrix)){
      stop("Please make sure you have run FindOptimalClusters on this AEMSet object before running this function.")
    }
    rand.idx.matrix <- object@Clusters$RandMatrix
  } else {
    if(!is.data.frame(object)){
      stop("Please supply a data frame.")
    }
    # Matrix must have the following column headers
    rand.colnames <- c("cluster.index.consec", "cluster.index.ref", "order", "stability_count", "cluster_count")
    if (!all.equal(rand.colnames, colnames(object@Clusters$RandMatrix))){
      stop("Please use the rand index matrix generated by FindOptimalClusters for this function.")
    }
    rand.idx.matrix <- object
  }

  rand.idx.matrix$stability_count <- rand.idx.matrix$stability_count/40
  key.stats.df <- as.data.frame(cbind(as.numeric(rand.idx.matrix$order)*0.025, rand.idx.matrix$stability_count, rand.idx.matrix$cluster.index.ref, rand.idx.matrix$cluster.index.consec, rand.idx.matrix$cluster_count/10))
  colnames(key.stats.df) <-c('Height', 'Stability', 'RandIndex', 'ConsecutiveRI', 'ClusterCount/10')

  key.stats.df$Height <-as.character(key.stats.df$Height)
  key.stats.tidy <- reshape2::melt(key.stats.df, id='Height')
  key.stats.tidy$Height <-as.numeric(key.stats.tidy$Height)

  diagnostic.plot <- ggplot2::ggplot(key.stats.tidy)
  diagnostic.plot <- diagnostic.plot + ggplot2::geom_line(ggplot2::aes(x=Height, y=value,  colour=variable)) + ggplot2::theme_bw() + ggplot2::theme(axis.text = ggplot2::element_text(size=11), axis.title = ggplot2::element_text(size=11))+ ggplot2::theme(legend.text = ggplot2::element_text(size=11)) + ggplot2::theme(legend.title = ggplot2::element_blank()) + ggplot2::xlab('Parameter from 0.025 to 1') + ggplot2::ylab('Scores')

  return(diagnostic.plot)
}

PlotClusterDendro <- function (dendro, colors, groupLabels = NULL, rowText = NULL,
                               rowTextAlignment = c("left", "center", "right"), rowTextIgnore = NULL,
                               textPositions = NULL, setLayout = TRUE, autoColorHeight = TRUE,
                               colorHeight = 0.2, rowWidths = NULL, dendroLabels = NULL,
                               addGuide = FALSE, guideAll = FALSE, guideCount = 50, guideHang = 0.2,
                               addTextGuide = FALSE, cex.colorLabels = 0.8, cex.dendroLabels = 0.9,
                               cex.rowText = 0.8, marAll = c(1, 5, 3, 1), saveMar = TRUE,
                               abHeight = NULL, abCol = "red", ...)
{
  dendro$labels <- rep('', length(dendro$labels))

  oldMar = par("mar")
  if (!is.null(dim(colors))) {
    nRows = dim(colors)[2]
  }
  else nRows = 1
  if (!is.null(rowText))
    nRows = nRows + if (is.null(textPositions))
      nRows
  else length(textPositions)
  if (autoColorHeight)
    colorHeight = 0.2 + 0.3 * (1 - exp(-(nRows - 1)/6))
  if (setLayout)
    layout(matrix(c(1:2), 2, 1), heights = c(1 - colorHeight,
                                             colorHeight))
  par(mar = c(0, marAll[2], marAll[3], marAll[4]))
  plot(dendro, labels = dendroLabels, cex = cex.dendroLabels,
       ...)
  if (addGuide)
    addGuideLines(dendro, count = if (guideAll)
      length(dendro$height) + 1
      else guideCount, hang = guideHang)
  if (!is.null(abHeight))
    abline(h = abHeight, col = abCol)
  par(mar = c(marAll[1], marAll[2], 0, marAll[4]))
  PlotConsensusBars(dendro, colors, groupLabels, cex.rowLabels = cex.colorLabels,
                    rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    cex.rowText = cex.rowText, rowWidths = rowWidths, addTextGuide = addTextGuide)
  if (saveMar)
    par(mar = oldMar)
}
#--------------plotColorUnderTree--------------#
PlotConsensusBars <- function (dendro, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, ...) {
  PlotOrderedColors(dendro$order, colors = colors, rowLabels = rowLabels,
                    rowWidths = rowWidths, rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    addTextGuide = addTextGuide, cex.rowLabels = cex.rowLabels,
                    cex.rowText = cex.rowText, startAt = 0, ...)
}
#--------------plotOrderedColors--------------#
PlotOrderedColors <- function (order, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, startAt = 0, ...) {
  colors = as.matrix(colors)
  dimC = dim(colors)

  # Create a colour ramp
  gradient_palette <- grDevices::colorRampPalette(c("#cc0000", "#000000"))
  palette(c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'))
  if (is.null(rowLabels) & (length(dimnames(colors)[[2]]) ==
                            dimC[2]))
    rowLabels = colnames(colors)
  sAF = options("stringsAsFactors")
  options(stringsAsFactors = FALSE)
  on.exit(options(stringsAsFactors = sAF[[1]]), TRUE)
  nColorRows = dimC[2]
  if (length(order) != dimC[1])
    stop("ERROR: length of colors vector not compatible with number of objects in 'order'.")
  C = colors[order, , drop = FALSE]
  step = 1/(dimC[1] - 1 + 2 * startAt)
  barplot(height = 1, col = "white", border = FALSE, space = 0,
          axes = FALSE)
  charWidth = strwidth("W")/2
  if (!is.null(rowText)) {
    if (is.null(textPositions))
      textPositions = c(1:nColorRows)
    if (is.logical(textPositions))
      textPositions = c(1:nColorRows)[textPositions]
    nTextRows = length(textPositions)
  }
  else nTextRows = 0
  nRows = nColorRows + nTextRows
  ystep = 1/nRows
  if (is.null(rowWidths)) {
    rowWidths = rep(ystep, nColorRows + nTextRows)
  }
  else {
    if (length(rowWidths) != nRows)
      stop("plotOrderedColors: Length of 'rowWidths' must equal the total number of rows.")
    rowWidths = rowWidths/sum(rowWidths)
  }
  hasText = rep(0, nColorRows)
  hasText[textPositions] = 1
  csPosition = cumsum(c(0, hasText[-nColorRows]))
  colorRows = c(1:nColorRows) + csPosition
  rowType = rep(2, nRows)
  rowType[colorRows] = 1
  physicalTextRow = c(1:nRows)[rowType == 2]
  yBottom = c(0, cumsum(rowWidths[nRows:1]))
  yTop = cumsum(rowWidths[nRows:1])
  if (!is.null(rowText)) {
    rowTextAlignment = match.arg(rowTextAlignment)
    rowText = as.matrix(rowText)
    textPos = list()
    textPosY = list()
    textLevs = list()
    for (tr in 1:nTextRows) {
      charHeight = max(strheight(rowText[, tr], cex = cex.rowText))
      width1 = rowWidths[physicalTextRow[tr]]
      nCharFit = floor(width1/charHeight/1.7/par("lheight"))
      if (nCharFit < 1)
        stop("Rows are too narrow to fit text. Consider decreasing cex.rowText.")
      set = textPositions[tr]
      textLevs[[tr]] = sort(unique(rowText[, tr]))
      textLevs[[tr]] = textLevs[[tr]][!textLevs[[tr]] %in%
                                        rowTextIgnore]
      nLevs = length(textLevs[[tr]])
      textPos[[tr]] = rep(0, nLevs)
      orderedText = rowText[order, tr]
      for (cl in 1:nLevs) {
        ind = orderedText == textLevs[[tr]][cl]
        sind = ind[-1]
        ind1 = ind[-length(ind)]
        starts = c(if (ind[1]) 1 else NULL, which(!ind1 &
                                                    sind) + 1)
        ends = which(c(ind1 & !sind, ind[length(ind)]))
        if (length(starts) == 0)
          starts = 1
        if (length(ends) == 0)
          ends = length(ind)
        if (ends[1] < starts[1])
          starts = c(1, starts)
        if (ends[length(ends)] < starts[length(starts)])
          ends = c(ends, length(ind))
        lengths = ends - starts
        long = which.max(lengths)
        textPos[[tr]][cl] = switch(rowTextAlignment,
                                   left = starts[long], center = (starts[long] +
                                                                    ends[long])/2 + 0.5, right = ends[long] +
                                     1)
      }
      if (rowTextAlignment == "left") {
        yPos = seq(from = 1, to = nCharFit, by = 1)/(nCharFit +
                                                       1)
      }
      else {
        yPos = seq(from = nCharFit, to = 1, by = -1)/(nCharFit +
                                                        1)
      }
      textPosY[[tr]] = rep(yPos, ceiling(nLevs/nCharFit) +
                             5)[1:nLevs][rank(textPos[[tr]])]
    }
  }
  jIndex = nRows
  if (is.null(rowLabels))
    rowLabels = c(1:nColorRows)
  C[is.na(C)] = "grey"
  for (j in 1:nColorRows) {
    jj = jIndex
    ind = (1:dimC[1])
    xl = (ind - 1.5 + startAt) * step
    xr = (ind - 0.5 + startAt) * step
    yb = rep(yBottom[jj], dimC[1])
    yt = rep(yTop[jj], dimC[1])
    if (is.null(dim(C))) {
      print(as.character(C))
      rect(xl, yb, xr, yt, col = as.character(C), border = as.character(C))
    }
    else {
      rect(xl, yb, xr, yt, col = as.character(C[, j]),
           border = as.character(C[, j]))
    }
    text(rowLabels[j], pos = 2, x = -charWidth/2 + xl[1],
         y = (yBottom[jj] + yTop[jj])/2, cex = cex.rowLabels,
         xpd = TRUE)
    textRow = match(j, textPositions)
    if (is.finite(textRow)) {
      jIndex = jIndex - 1
      xt = (textPos[[textRow]] - 1.5) * step
      xt[xt < par("usr")[1]] = par("usr")[1]
      xt[xt > par("usr")[2]] = par("usr")[2]
      yt = yBottom[jIndex] + (yTop[jIndex] - yBottom[jIndex]) *
        (textPosY[[textRow]] + 1/(2 * nCharFit + 2))
      nt = length(textLevs[[textRow]])
      if (addTextGuide)
        for (l in 1:nt) lines(c(xt[l], xt[l]), c(yt[l],
                                                 yTop[jIndex]), col = "darkgrey", lty = 3)
      textAdj = c(0, 0.5, 1)[match(rowTextAlignment, c("left",
                                                       "center", "right"))]
      text(textLevs[[textRow]], x = xt, y = yt, adj = c(textAdj,
                                                        1), xpd = TRUE, cex = cex.rowText)
    }
    jIndex = jIndex - 1
  }
  for (j in 0:(nColorRows + nTextRows)) lines(x = c(0, 1),
                                              y = c(yBottom[j + 1], yBottom[j + 1]))
}

#' PlotStabilityDendro
#'
#' @param object A \linkS4class{AEMSet} that has undergone clustering.
#'
PlotStabilityDendro <- function(object){
  # Check that the user has done the required steps.
  if (length(object@Clusters) == 0){
    stop("Please run FindOptimalClusters on this object before using this function.")
  }

  # Get the variables
  dendro <- object@Clusters$Hclust
  colours <- object@Clusters$ClusteringMatrix

  # Plotting function
  print(PlotClusterDendro(dendro, colours))
}


#' PlotMDS
#'
#' Generates a Multi-Dimensional Scaling (MDS) plot.
#'
#'  @param object An \linkS4class{AEMSet} that has undergone clustering with \code{FindOptimalClusters}.
#'  @param PCA If true, use PCA-reduced matrix to generate MDS plot
#'  @param dim1 Which dimension to plot on the x-axis
#'  @param dim2 Which dimension to plot on the y-axis
#'  @param column (Optional) Name of the column in CellIdentifiers that describe a set of conditions you would like to colour cells by
#'
PlotMDS <- function(object, PCA = FALSE, dim1 = 1, dim2 = 2, column = NULL){
  if (class(object) != "AEMSet"){
    stop("Please supply an AEMSet object.")
  }

  # Check the column has been defined
  if (!is.null(column)){
    if (is.null(object@CellInformation[ ,column])){
      stop("Please ensure your specified column exists.")
    } else{
      condition.list <- object@CellInformation[, column]
      names(condition.list) <- object@CellInformation[,1]
    }
  }

  # Retrieve distance matrix
  if (PCA){
    # Stop if user hasn't run PCA.
    if (length(object@PCA) == 0){
      stop("Please use RunPCA on this object before using the PCA argument for this function.")
    }

    # Retrieve distance matrix
    if (length(object@Clusters) > 0){
      distance.matrix <- object@Clusters$DistanceMatrix
    } else{
      pca.matrix <- object@PCA$PCA
      if (ncol(pca.matrix) >= 20){
        n <- 20
        pca.matrix <- pca.matrix[,1:n]
      } else{
        n <- ncol(pca.matrix)
      }
      print(sprintf("Calculating distance matrix from top %s PCAs..."), n)
      distance.matrix <- stats::dist(pca.matrix)
    }
  } else{
    print("Calculating distance matrix from expression data...")
    expression.matrix <- GetExpressionMatrix(object, "matrix")
    gene.variance <- CalcRowVariance(expression.matrix)
    names(gene.variance) <- rownames(expression.matrix)
    sorted.gene.variance <- gene.variance[order(unlist(gene.variance), decreasing = TRUE)]
    top.genes <- sorted.gene.variance[1:1000]

    # Subsetting matrix
    subset.matrix <- expression.matrix[names(top.genes), ]
    subset.matrix <- t(subset.matrix)
    # Create distance matrix
    distance.matrix <- stats::dist(subset.matrix)
  }

  # Scale matrix
  print("Running cmdscale...")
  mds.matrix <-stats::cmdscale(distance.matrix, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE)
  print("Cmdscale complete! Processing scaled data...")
  mds.matrix <- as.data.frame(mds.matrix)
  colnames(mds.matrix) <- c("Dim1", "Dim2")

  print("Generating MDS plot...")
  if (length(condition.list) > 0){
    mds.matrix$condition <- unlist(condition.list)
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2, col=factor(condition))) + ggplot2::geom_point(alpha = 0.5) + ggplot2::labs(colour = "Condition")
  } else{
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }
  return(mds.plot)
}

#' PlotTSNE
#'
#' Generates a 2D TSNE plot.
#'
#' @param object An \linkS4class{AEMSet}.
#' @param PCA Set to FALSE to not use PCA-reduced values
#' @param column (Optional) Name of the column in CellIdentifiers that describe a set of conditions you would like to colour cells by
#' @param seed (Optional) Set to a specific value for reproducible TSNE plots
#' @param perplexity (Optional) Numeric; perplexity parameter
#' @param theta (Optional) Numeric; Speed/accuracy trade-off (increase for less accuracy)
#'
PlotTSNE <- function(object, PCA = TRUE, column = NULL, seed = 0, perplexity = 30, theta = 0.5){
  # Input checks
  if (class(object) != "AEMSet"){
    stop("Please supply an AEMSet to this function.")
  }

  # Check the column has been defined
  if (!is.null(column)){
    if (is.null(object@CellInformation[ ,column])){
      stop("Please ensure your specified column exists.")
    } else{
      condition.list <- object@CellInformation[, column]
      names(condition.list) <- object@CellInformation[,1]
    }
  }

  if(PCA){
    if (!(length(object@PCA) > 0)){
      stop("Please reduce this dataset with RunPCA before using this function.")
    } else{
      pca.barcodes <- rownames(object@PCA$PCA)
      condition.list <- condition.list[pca.barcodes]
      if (!(length(condition.list) > 0)){
        stop("Please ensure all cell identifiers specified in the condition list are in the AEMSet.")
      }
    }
  } else{
    if (!all(names(condition.list) %in% object@ExpressionMatrix)){
      stop("Please ensure all cell identifiers specified in the condition list are in the AEMSet.")
    }
  }

  # Run TSNE in 2D
  tsne.df<- RunTSNE(object, PCA = PCA, dimensions = 2, seed = seed, perplexity = perplexity, theta = theta)

  # Generate Plots
  if (length(condition.list) > 0){
    tsne.df$conditions <- as.factor(unlist(condition.list))
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)), alpha = 0.5) + ggplot2::labs(colour = "Condition")
  } else{
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }

  return(tsne.plot)
}

#' PlotPCA
#'
#' Plot two principal components (PCs) on a scatter plot.
#'
#' @param object An \linkS4class{AEMSet} object that has undergone PCA
#' @param dim1 Principal component to plot on the x-axis
#' @param dim2 Principal component to plot on the y-axis
#' @param column (Optional) Name of the column in CellIdentifiers that describe a set of conditions you would like to colour cells by
#'
PlotPCA <- function(object, dim1 = 1, dim2 = 2, column = NULL){
  # Check if PCA has been run
  if(length(object@PCA) == 0){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  # Check the column has been defined
  if (!is.null(column)){
    if (is.null(object@CellInformation[ ,column])){
      stop("Please ensure your specified column exists.")
    } else{
      condition.list <- object@CellInformation[, column]
      names(condition.list) <- object@CellInformation[,1]
    }
  }

  # Extract dimensions to plot
  pca.matrix <- object@PCA$PCA
  plot.matrix <- pca.matrix[,c(dim1, dim2)]
  colnames(plot.matrix) <- c("x", "y")

  if (length(condition.list) > 0){
    plot.matrix$conditions <- as.factor(unlist(condition.list))
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)), alpha = 0.5) + ggplot2::labs(colour = "Condition")
  } else{
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }

  return(pca.plot)
}

#' PlotPCAVariance
#'
#' Plots PCA Percent Variance.
#'
#' @param object An \linkS4class{AEMSet} that has undergone PCA.
#' @param n Number of PCA values on the plot
#'
PlotPCAVariance <- function(object, n){
  if(is.null(object@PCA$PCAPercentVariance)){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  pca.obj <- ggplot2::qplot(y=object@PCA$PCAPercentVariance[1:n], x=1:n, geom="point", xlab="Principal Component (PC)", ylab="% Variance", main="Percent Variance per PC")
  return(pca.obj)

}

#' PlotNormalisationQC
#'
#' Generates a series of plots comparing an un-normalised and a normalised \linkS4class{AEMSet}.
#'
#' @param original An un-normalised \linkS4class{AEMSet}
#' @param normalised A normalised \linkS4class{AEMSet}
#' @param gene Gene to plot expression levels for (optional)
#'
PlotNormalisationQC <- function(original = NULL, normalised = NULL, gene.list = list()) {
  # Insert Check For Normalisation
  if(!is.null(original@Log$NormalisationMethod)){
    stop("Please supply an un-normalised AEMSet object.")
  }

  if(is.null(normalised@Log$NormalisationMethod)){
    stop("Please supply a normalised AEMSet object.")
  }

  # Set output
  output.list <- list()

  # Get metrics we need from old and new object
  print("Retrieving data from AEMSets...")
  matrix.1 <- GetExpressionMatrix(original, "data.frame")
  matrix.2 <- GetExpressionMatrix(normalised, "data.frame")

  # As normalisation removes cells and genes, trim original matrix.
  common.rows <- intersect(rownames(matrix.1), rownames(matrix.2))
  common.cols <- intersect(colnames(matrix.1), colnames(matrix.1))
  matrix.1 <- matrix.1[common.rows, common.cols]

  # Retrieve library sizes
  libsize.1 <- original@Metrics$TotalCounts
  libsize.2 <- normalised@Metrics$TotalCounts

  # Retrieve feature counts
  cells.per.gene.1 <- original@Metrics$CellsPerGene
  cells.per.gene.2 <- normalised@Metrics$CellsPerGene

  # Generate histogram
  print("Plotting libsize histograms...")
  # Combine libsizes
  libsize.df.1 <- data.frame(Libsize = libsize.1, Dataset=rep("Original", length(libsize.1)))
  libsize.df.2 <- data.frame(Libsize = libsize.2, Dataset=rep("Normalised", length(libsize.2)))

  # Get largest library size
  max.libsize <- max(c(libsize.1, libsize.2))
  libsize.df <- rbind(libsize.df.1, libsize.df.2)
  libsize.hist <- ggplot2::ggplot(libsize.df, ggplot2::aes(Libsize, fill = Dataset)) + ggplot2::geom_histogram(alpha = 0.5, position = "identity", binwidth = 1000) + ggplot2::xlab("Library size") + ggplot2::ylab("Number of cells") + ggplot2::ggtitle("Library sizes across cells")
  max.counts <- max(ggplot2::ggplot_build(libsize.hist)$data[[1]]$count)

  libsize.hist.1 <- ggplot2::qplot(libsize.1, xlim = c(0, max.libsize * 1.1), ylim = c(0, max.counts * 1.1), main = "Before normalisation", xlab = "Library size", ylab = "Number of cells", binwidth = 1000)
  libsize.hist.2 <- ggplot2::qplot(libsize.2, xlim = c(0, max.libsize * 1.1), ylim = c(0, max.counts * 1.1), main = "After normalisation", xlab = "Library size", ylab = "Number of cells", binwidth = 1000)

  #output.libsize.hist <- gridExtra::grid.arrange(libsize.hist.1, libsize.hist.2, ncol = 2)
  output.list <- c(output.list, list(Libsize=list(Original = libsize.hist.1, Normalised = libsize.hist.2)))

  # Remove zero counts
  matrix.1 <- matrix.1[which(rowSums(matrix.1) > 0),]
  matrix.2 <- matrix.2[which(rowSums(matrix.2) > 0),]

  # Plot scatter for housekeeping genes
  if(length(gene.list) > 0){
    gene.scatter.list <- list()
    for (gene in gene.list){
      # Check if there are any counts
      gene.counts.1 <- matrix.1[gene, ][which(matrix.1[gene, ] > 0)]
      gene.counts.2 <- matrix.2[gene, ][which(matrix.2[gene, ] > 0)]

      if((length(gene.counts.1) > 0) && (length(gene.counts.2) > 0)){
        print(sprintf("Plotting %s expression...", gene))

        # Get ylim
        ylim.1 <- max(gene.counts.1)
        ylim.2 <- max(gene.counts.2)
        ylim.max <- (max(ylim.1, ylim.2)) * 1.1

        gene.scatter.1 <- ggplot2::qplot(x = 1:length(gene.counts.1), y = unlist(gene.counts.1), geom="point", alpha=0.2, main=sprintf('Expression of %s (Before normalisation)', gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
        gene.scatter.2 <- ggplot2::qplot(x = 1:length(gene.counts.2), y = unlist(gene.counts.2), geom="point", alpha=0.2, main=sprintf('Expression of %s (After normalisation)', gene), xlab="Cells", ylab="Gene expression", ylim = c(0, ylim.max))
        gene.scatter.list[[gene]] <- list(Original = gene.scatter.1, Normalised = gene.scatter.2)
      }
    }
    output.list <- c(output.list, list(GeneScatterPlots=gene.scatter.list))}
  else{
    # While loop - look for a suitable gene
    success <- FALSE
    while (!success){
      gene <- sample(rownames(matrix.2), 1)
      gene.counts.1 <- matrix.1[gene,][which(matrix.1[gene, ] > 0)]
      gene.counts.2 <- matrix.2[gene,][which(matrix.2[gene, ] > 0)]
      success <- (length(gene.counts.1) > 10) && (length(gene.counts.2) > 10)
    }

    # Found a gene!
    print(sprintf("Plotting %s expression...", gene))
    # Get ylim
    ylim.1 <- max(gene.counts.1)
    ylim.2<- max(gene.counts.2)
    ylim.max <- max(ylim.1, ylim.2) * 1.1

    gene.scatter.1 <- ggplot2::qplot(x = 1:length(gene.counts.1), y = unlist(gene.counts.1), geom="point", alpha=0.2, main = sprintf("Expression of %s (Before normalisation)", gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
    gene.scatter.2 <- ggplot2::qplot(x = 1:length(gene.counts.2), y = unlist(gene.counts.2), geom="point", alpha=0.2, main = sprintf("Expression of %s (After normalisation)", gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
    output.list <- c(output.list, list(GeneScatterPlots = list(Original = gene.scatter.1, Normalised = gene.scatter.2)))
  }

  # Generate box plots
  print("Plotting gene expression box plots...")
  # Generate box plots
  print("Plotting gene expression box plots...")
  ordered.1 <- matrix.1[order(rowSums(matrix.1), decreasing=T),]
  ordered.2 <- matrix.2[order(rowSums(matrix.2), decreasing=T),]

  ordered.1 <- stack(ordered.1[,1:100])
  ordered.2 <- stack(ordered.2[,1:100])

  ylim <- max(ordered.1$values[1], ordered.2$values[1])

  boxplot.1 <- ggplot2::ggplot(ordered.1, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot() + ggplot2::scale_y_continuous(limits = c(0, ylim*1.1))
  boxplot.2 <- ggplot2::ggplot(ordered.2, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot() + ggplot2::scale_y_continuous(limits = c(0, ylim*1.1))

  boxplot.1 <- boxplot.1 + ggplot2::labs(title='Gene expression (Before normalisation)',  y='Gene expression', x='Cells')
  boxplot.2 <- boxplot.2 + ggplot2::labs(title='Gene expression (After normalisation)',  y='Gene expression', x='Cells')

  boxplot.1 <- boxplot.1 + ggplot2::theme(axis.text.x = ggplot2::element_blank())
  boxplot.2 <- boxplot.2 + ggplot2::theme(axis.text.x = ggplot2::element_blank())

  print("Plots complete!")

  # Return a list of output
  output.list <- c(output.list, list(GeneExpressionBoxplot = list(Original = boxplot.1, Normalised = boxplot.2)))
  return(output.list)
}


# From perceptions - https://github.com/zonination/perceptions
# Generate the colors for the chart procedurally with RColorBrewer
z_theme <- function() {
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[2]
  color.grid.major = palette[5]
  color.axis.text = palette[7]
  color.axis.title = palette[7]
  color.title = palette[8]
  # Begin construction of chart
  ggplot2::theme_bw(base_size=9) +
    # Set the entire chart region to a light gray color
    ggplot2::theme(panel.background = ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(plot.background= ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(panel.border= ggplot2::element_rect(color=color.background)) +
    # Format the grid
    ggplot2::theme(panel.grid.major= ggplot2::element_line(color=color.grid.major,size=.25)) +
    ggplot2::theme(panel.grid.minor= ggplot2::element_blank()) +
    ggplot2::theme(axis.ticks= ggplot2::element_blank()) +
    # Format the legend, but hide by default
    ggplot2::theme(legend.position="none") +
    ggplot2::theme(legend.background = ggplot2::element_rect(fill=color.background)) +
    ggplot2::theme(legend.text = ggplot2::element_text(size=7,color=color.axis.title)) +
    # Set title and axis labels, and format these and tick marks
    ggplot2::theme(plot.title = ggplot2::element_text(color=color.title, size=20, vjust=1.25)) +
    ggplot2::theme(axis.text.x = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.text.y = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.title.x = ggplot2::element_text(size=16, color=color.axis.title, vjust=0)) +
    ggplot2::theme(axis.title.y = ggplot2::element_text(size=16, color=color.axis.title, vjust=1.25))
}

#' PlotTopGenesPerSample
#'
#' Generates a violin-beeswarm plot of top genes per sample.
#'
#' @param An \linkS4class{AEMSet} object
#'
PlotTopGenesPerSample <- function(object){
  # Generate tidy data
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  top.gene.list <- object@Metrics$TopGeneList
  metrics <- object@Metrics

  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  batch.names <- unique(present.batches)

  # Prepare Top 500
  top.500.gene.list <- top.gene.list[1:500]
  subset.500.mtx <- expression.matrix[top.500.gene.list,]
  top.500.percentage <- 100 * colSums(subset.500.mtx)/colSums(expression.matrix)

  # Prepare Top 100
  top.100.gene.list <- top.gene.list[1:100]
  subset.100.mtx <- expression.matrix[top.100.gene.list,]
  top.100.percentage <- 100 * colSums(subset.100.mtx)/colSums(expression.matrix)

  ## Tidy dataframe
  combined.data <- list(Percentage500 = top.500.percentage, Percentage100 = top.100.percentage, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentage500, colour = Percentage100))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotLibrarySizesPerSample
#'
#' Generates a violin-beeswarm plot of library sizes per sample.
#' @param object A \linkS4class{AEMSet}
#'
PlotLibrarySizesPerSample <- function(object){
  # Tidy data to feed into ggplot
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  total.counts <- metrics$TotalCounts[present.barcodes]
  total.features <- metrics$TotalFeatureCountsPerCell[present.barcodes]
  batch.names <- unique(present.batches)

  ## Tidy dataframe
  combined.data <- list(TotalCounts = total.counts, FeatureCounts = total.features, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = TotalCounts, colour = FeatureCounts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotControlPercentagesPerSample
#'
#' @param object A \linkS4class{AEMSet} object
#' @param control.name Name of the control you would like to plot
#'
PlotControlPercentagesPerSample <- function(object, control.name){
  # Tidy data to feed into ggplot
  ## Load data from the object
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  subset.control.percentages <- metrics$PercentageTotalCounts[[control.name]][present.barcodes]
  subset.counts <- metrics$ControlTranscriptCounts[[control.name]][present.barcodes]
  batch.names <- unique(present.batches)

  ## Combine into a tidy dataframe
  combined.data <- list(Percentages = subset.control.percentages, Counts = subset.counts, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # Use ggplot to generate a violin/beeswarm plot
  ## Colour palette
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  plot.title <- sprintf("Percentage of reads mapped to %s genes", control.name)

  ## ggplot call
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentages, colour = Counts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("% Reads")  + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(control.plot)
}


#' PlotTopGeneExpression
#'
#' Generates a boxplot using \link[ggplot2]{geom_boxplot} of the most expressed genes in the dataset, in a range defined by the user.
#' @param object A AEMSet object
#' @param n Number of genes to be plotted
#'
PlotTopGeneExpression <- function(object, n = 50, controls = TRUE){
  # Prep data to feed in
  if(!controls){
    control.list <- object@Controls
    if(names(control.list) == c("Mt", "Rb")){
      object <- ExcludeControl(object, "Mt")
      object <- ExcludeControl(object, "Rb")
    }
  }

  plot.title <- sprintf("Top %i Expressed Genes", n)
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  counts.per.gene <- object@Metrics$CountsPerGene
  total.expression <- object@Metrics$TotalExpression
  top.gene.list <- object@Metrics$TopGeneList[1:n]

  subset.exprs.mtx <- expression.matrix[top.gene.list,]
  sorted.counts.per.gene <- sort(counts.per.gene, decreasing = TRUE)
  top.genes.percentage <- 100 * sum(sorted.counts.per.gene[1:n])/total.expression
  top.gene.expression.per.cell <- (100 * subset.exprs.mtx)/colSums(expression.matrix)

  transposed.gene.expression <- t(top.gene.expression.per.cell)
  melted.gene.expression <- reshape2::melt(as.matrix(transposed.gene.expression))
  melted.gene.expression$Var2 <- factor(melted.gene.expression$Var2, levels = (rev(top.gene.list)))
  ggplot.obj <- ggplot2::ggplot(melted.gene.expression, ggplot2::aes(y = value,x = Var2)) + ggplot2::geom_boxplot(ggplot2::aes(fill=Var2), alpha=.5, outlier.colour = NULL)
  ggplot.obj <- ggplot.obj + ggplot2::coord_flip() + z_theme() + ggplot2::xlab("Gene") + ggplot2::ylab("% Expression") + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(ggplot.obj)
}

#' PlotGeneralQC
#'
#' This function generates the following plots:
#' \itemize{
#' \item{\strong{Library Size}: A histogram depicting library sizes across the dataset.}
#' }
#' @param object An \linkS4class{AEMSet} object
#'
PlotGeneralQC <- function(object){
  output.list <- list()
  # General Plots
  # 1. Plot library sizes and expressed gene histograms
  print("Plotting Total Count and Library Size...")
  libsize.plot <- ggplot2::qplot(object@Metrics$TotalCounts, geom="histogram", main="Distribution of library sizes across dataset", xlab="Library size", ylab="Number of cells", binwidth=1000) + ggplot2::theme_bw()
  output.list[["LibSize"]] <- libsize.plot

  print("Plotting Average Counts...")
  smooth.scatter <- graphics::smoothScatter(log10(object@Metrics$AverageCounts), object@Metrics$CellsPerGene, xlab=expression(Log[10]~"Average Count"),ylab="Number of expressing cells", main = "Average gene expression across cells")
  average.gene.count <- ggplot2::qplot(object@Metrics$AverageCounts, xlab="Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 10) + ggplot2::theme_bw()
  log2.average.count <- ggplot2::qplot(log2(object@Metrics$AverageCounts)[!is.infinite(log2(object@Metrics$AverageCounts))], geom="histogram", xlab=Log[2]~"Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 1) + ggplot2::theme_bw()
  log10.average.gene.count <- ggplot2::qplot(log10(object@Metrics$AverageCounts)[!is.infinite(log10(object@Metrics$AverageCounts))], geom="histogram", xlab=Log[10]~"Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 0.1) + ggplot2::theme_bw()

  output.list[["Log10AverageGeneCount"]] <- log10.average.gene.count
  output.list[["AverageCountSmoothScatter"]] <- smooth.scatter
  output.list[["Log2AverageGeneCount"]] <- log2.average.count
  output.list[["AverageGeneCount"]] <- average.gene.count

  # 2. Average Counts
  if (object@Log$Controls){
    # Plots that need controls
    # 1. Plot library sizes and expressed gene histograms
    feature.counts.per.cell <- ggplot2::qplot(object@Metrics$TotalFeatureCountsPerCell, geom="histogram", xlab="Number of expressed genes", main="Number of expressed genes across cells", ylab="Number of cells", binwidth = 250) + ggplot2::theme_bw()
    output.list[["FeatureCountsPerCell"]] <- feature.counts.per.cell

    # 2. Proportion of Controls
    print("Plotting Proportion of Control Histograms...")
    percentage.total.plots <- list()
    for (control.name in names(object@Metrics$PercentageTotalCounts)){
      xlab.string <- paste0("%", sprintf("%s proportion ", control.name))
      title.string <- sprintf("Proportion of control: %s", control.name)
      percentage.total.counts <- as.data.frame(object@Metrics$PercentageTotalCounts[[control.name]])
      colnames(percentage.total.counts) <- c("Percentage")
      pct.hist <- ggplot2::ggplot(percentage.total.counts, aes(Percentage)) + ggplot2::geom_histogram(binwidth = 5) + ggplot2::ggtitle(title.string) + ggplot2::theme_bw()
      pct.hist <- pct.hist + ggplot2::xlab(xlab.string) + ggplot2::ylab("Number of cells") + ggplot2::ggtitle(title.string)
      percentage.total.plots[[control.name]] <- pct.hist
    }

    # 6. Plot Controls Per Sample
    print("Using ggplot2 to plot Control Percentages...")
    percentage.sample.list <- list()
    for (control.name in names(object@Controls)){
      control.pct.plot <- PlotControlPercentagesPerSample(object, control.name)
      percentage.sample.list[[control.name]] <- control.pct.plot
    }

    output.list[["ControlPercentageTotalCounts"]] <- percentage.total.plots
    output.list[["ControlPercentageSampleCounts"]] <- percentage.sample.list

    # 4. Plot Library Sizes per Sample
    print("Using ggplot2 to plot Library Sizes Per Sample...")
    library.size.plot <- PlotLibrarySizesPerSample(object)
    output.list[["LibSizePerSample"]] <- library.size.plot

  }


  # 5. Plot Genes per Sample
  print("Using ggplot2 to plot Top Genes Per Sample...")
  genes.per.sample.plot <- PlotTopGenesPerSample(object)
  output.list[["TopGenesPerSample"]] <- genes.per.sample.plot

  # 7. Plot Top Genes
  print("Using ggplot2 to plot Top Gene Expression...")
  top.genes.plot <- PlotTopGeneExpression(object)
  output.list[["TopGenes"]] <- top.genes.plot
  return(output.list)
}
