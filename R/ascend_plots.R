#' PlotDEVolcano
#'
#' Produces a volcano plot featuring differential expression results.
#'
#' @param de.results Differential expression results generated by 
#' \code{\link{RunDiffExpression}}.
#' @param threshold Threshold to determine significant results by (Default: 5e-3).
#' @param l2fc Threshold to determine significant Log2FoldChange by (Default: 2).
#' @param labels Display names of significant results on plot (Default: FALSE).
#' @param label.size Size of label text (Default: 5).
#' @return A scatter plot rendered by ggplot2's geom_point.
#' @examples
#' \dontrun{
#' library(ggplot2)
#' my_volcano_plot <- PlotDEVolcano(de_result_df, threshold = 5e-3, l2fc = 2) +
#' ggtitle("My Volcano Plot")
#' }
#' @importFrom ggplot2 ggplot geom_point scale_color_manual xlab ylab theme_bw geom_text aes
#' @export
#'
PlotDEVolcano <- function(de.results, threshold = 5e-3, l2fc = 2, labels = FALSE, label.size = 5){
  # Check data frame contains required information
  required.cols <- c("id", "padj", "log2FoldChange")
  if (!is.data.frame(de.results)){
    stop("Please supply a data frame.")
  } else{
   if(!any(required.cols %in% colnames(de.results))){
    stop("Please make sure your dataframe has the following columns: id, padj, log2FoldChange")
   }
  }

  # Convert adjusted p-values to log10
  de.results$padj <- -log10(de.results$padj)

  # Find significant limits
  padj.limit <- -log10(threshold)
  fc.limit.up <- l2fc
  fc.limit.down <- -l2fc

  # Add groups to DF ("normal" and "significant")
  de.results$group <- rep("Normal", nrow(de.results))
  sig.upregulated <- de.results$log2FoldChange > fc.limit.up & de.results$padj > padj.limit
  sig.downregulated <- de.results$log2FoldChange < fc.limit.down & de.results$padj > padj.limit

  if (any(sig.upregulated)){
    de.results[sig.upregulated, ]$group <- "Significant"
  }

  if (any(sig.downregulated)){
    de.results[sig.downregulated, ]$group <- "Significant"
  }

  # Generate volcano plot
  volcano.plot <- ggplot2::ggplot(de.results, ggplot2::aes(log2FoldChange, padj)) +
    ggplot2::geom_point(ggplot2::aes(colour = group)) +
    ggplot2::scale_colour_manual(name = "", values = c("Normal"="#323234", "Significant"="#014abb")) +
    ggplot2::xlab('log2 Fold Change') +
    ggplot2::ylab('-log10 adjusted P-value') +
    ggplot2::theme_bw()

  if(labels){
    if (any(sig.upregulated)){
      volcano.plot <- volcano.plot + ggplot2::geom_text(data = subset(de.results, padj > padj.limit & log2FoldChange > fc.limit.up), ggplot2::aes(log2FoldChange, padj, label = id), size = label.size, vjust = 0, nudge_y = 2.5)
    }
    if (any(sig.downregulated)){
      volcano.plot <- volcano.plot + ggplot2::geom_text(data = subset(de.results, padj > padj.limit & log2FoldChange < fc.limit.down), ggplot2::aes(log2FoldChange, padj, label = id), size = label.size, vjust = 0, nudge_y = 2.5)
    }
  }
  return(volcano.plot)
}

#' PlotDendrogram
#' 
#' Generates a colour-labelled dendrogram to the device, using a clustered
#' \code{\linkS4class{EMSet}}.
#' 
#' @param object An \code{\linkS4class{EMSet}} that has undergone clustering.
#' @importFrom stats as.dendrogram order.dendrogram
#' @importFrom dendextend branches_attr_by_clusters set get_leaves_branches_col sort_levels_values colored_bars get_leaves_branches_attr
#' @importFrom graphics legend
#' @export
#'
PlotDendrogram <- function(object){
  # Input Checks
  if(class(object) == "EMSet"){
    if(is.null(object@Clusters$Hclust)){
      stop("Please make sure you have run RunCORE on this EMSet object before using this function.")
    }
  } else{
    stop("Please supply a EMSet object to this function.")
  }

  # Extract required values from the object
  hclust.obj <- object@Clusters$Hclust
  optimal.height <- object@Clusters$OptimalTreeHeight
  nclusters <- object@Clusters$NumberOfClusters
  cluster.list <- object@Clusters$Clusters
  
  # Count table
  cluster.df <- as.data.frame(table(cluster.list))
  dendro.obj <- as.dendrogram(hclust.obj)
  
  # Reorder count table to match dendrogram order
  cluster.order <- order.dendrogram(dendro.obj)
  ordered.clusters <- as.vector(cluster.list)[cluster.order]
  cluster.df <- cluster.df[match(unique(ordered.clusters), cluster.df$cluster.list), ]
  
  # Generate coloured plot
  coloured.dendro <- dendextend::branches_attr_by_clusters(dendro.obj, clusters = ordered.clusters, attr = 'col')
  coloured.dendro <- dendextend::set(coloured.dendro, "labels", "")
  plot(coloured.dendro)
  
  # Generate cluster bar underneath
  dendro.colours <- unique(dendextend::get_leaves_branches_col(coloured.dendro))
  coloured.order <- cluster.order
  sorted.levels <- dendextend::sort_levels_values(as.vector(cluster.list)[coloured.order])
  sorted.levels <- sorted.levels[match(seq_along(coloured.order), coloured.order)]
  dendextend::colored_bars(dendro.colours[sorted.levels], coloured.dendro, rowLabels = "Cluster")
  
  # Get branch colours
  colour.order <- unique(coloured.dendro %>% dendextend::get_leaves_branches_attr("col"))
  
  # Generate legend labels
  legend.labels <- sapply(1:nrow(cluster.df), function(x) paste0("Cluster ", cluster.df$cluster.list[x], ": ", cluster.df$Freq[x]))
  legend("topright", legend = c(legend.labels), fill = colour.order, border = colour.order, bty = "n", title = "Cluster Populations")
}

#' PlotStability
#'
#' Plots Stability, Consecutive RI and Rand Index. This can be used to determine
#' the optimal resolution of the clustering results.
#'
#' @param object An \code{\linkS4class{EMSet}} object that has undergone clustering.
#' @importFrom reshape2 melt
#' @importFrom ggplot2 ggplot geom_line theme_bw theme element_text aes xlab ylab
#' @export
#'
PlotStability <- function(object){
  # User can supply a EMSet or data frame with rand results to this function
  if(class(object) == "EMSet"){
    if (is.null(object@Clusters$RandMatrix)){
      stop("Please make sure you have run RunCORE on this EMSet object before running this function.")
    }
    rand.idx.matrix <- object@Clusters$RandMatrix
  } else {
    if(!is.data.frame(object)){
      stop("Please supply a data frame.")
    }
    # Matrix must have the following column headers
    rand.colnames <- c("cluster.index.consec", "cluster.index.ref", "order", "stability_count", "cluster_count")
    if (!all.equal(rand.colnames, colnames(object@Clusters$RandMatrix))){
      stop("Please use the rand index matrix generated by RunCORE for this function.")
    }
    rand.idx.matrix <- object
  }

  rand.idx.matrix$stability_count <- rand.idx.matrix$stability_count/40
  key.stats.df <- as.data.frame(cbind(as.numeric(rand.idx.matrix$order)*0.025, rand.idx.matrix$stability_count, rand.idx.matrix$cluster.index.ref, rand.idx.matrix$cluster.index.consec, rand.idx.matrix$cluster_count/10))
  colnames(key.stats.df) <-c('Height', 'Stability', 'RandIndex', 'ConsecutiveRI', 'ClusterCount/10')

  key.stats.df$Height <-as.character(key.stats.df$Height)
  key.stats.tidy <- reshape2::melt(key.stats.df, id='Height')
  key.stats.tidy$Height <-as.numeric(key.stats.tidy$Height)

  diagnostic.plot <- ggplot2::ggplot(key.stats.tidy)
  diagnostic.plot <- diagnostic.plot + ggplot2::geom_line(ggplot2::aes(x=Height, y=value,  colour=variable)) + ggplot2::theme_bw() + ggplot2::theme(axis.text = ggplot2::element_text(size=11), axis.title = ggplot2::element_text(size=11))+ ggplot2::theme(legend.text = ggplot2::element_text(size=11)) + ggplot2::theme(legend.title = ggplot2::element_blank()) + ggplot2::xlab('Parameter from 0.025 to 1') + ggplot2::ylab('Scores')

  return(diagnostic.plot)
}

#' PlotClusterDendro
#' 
#' This function was adapted from the plotDendroAndColors function by Steve 
#' Horvarth, Peter Langelder, and Tal Galili (\pkg{WGCNA}).
#' 
#' @param dendro Hclust object generated from \code{\link{RunCORE}}.
#' @param colors List of colours to use to label each cluster combination. Must 
#' be equal to the number of resolutions.
#' @param groupLabels List of labels.
#' @param rowText Row text.
#' @param rowTextAlignment Positioning of row text.
#' @param rowTextIgnore Whether to ignore row text.
#' @param textPositions Shift positioning of text.
#' @param setLayout Set the layout.
#' @param autoColorHeight Boolean.
#' @param colorHeight Height of colour bars.
#' @param rowWidths Width of bars.
#' @param dendroLabels Labels on dendrogram.
#' @param addGuide Add legend to image.
#' @param guideAll Add guides to all.
#' @param guideCounts Number of guides (Default: 50).
#' @param guideHang Hang guide off dendrogram (Default: 0.2).
#' @param addTextGuide Set to FALSE (Default).
#' @param cex.colorLabels Set to 0.8 (Default).
#' @param cex.dendroLabels Set to 0.9 (Default).
#' @param cex.rowText Set to 0.8 (Default).
#' @param marAll Margins set to 1, 5, 3 and 1 (Default).
#' @param saveMar Set to TRUE (Default).
#' @param abHeight Set to NULL (Default).
#' @param abCol Set to red (Default).
#' @param ... Additional parameters to feed into graphics function.
#' @importFrom graphics par layout abline plot 
#' 
PlotClusterDendro <- function (dendro, colors, groupLabels = NULL, rowText = NULL,
                               rowTextAlignment = c("left", "center", "right"), rowTextIgnore = NULL,
                               textPositions = NULL, setLayout = TRUE, autoColorHeight = TRUE,
                               colorHeight = 0.2, rowWidths = NULL, dendroLabels = NULL,
                               addGuide = FALSE, guideAll = FALSE, guideCount = 50, guideHang = 0.2,
                               addTextGuide = FALSE, cex.colorLabels = 0.8, cex.dendroLabels = 0.9,
                               cex.rowText = 0.8, marAll = c(1, 5, 3, 1), saveMar = TRUE,
                               abHeight = NULL, abCol = "red", ...)
{
  dendro$labels <- rep('', length(dendro$labels))

  oldMar = par("mar")
  if (!is.null(dim(colors))) {
    nRows = dim(colors)[2]
  }
  else nRows = 1
  if (!is.null(rowText))
    nRows = nRows + if (is.null(textPositions))
      nRows
  else length(textPositions)
  if (autoColorHeight)
    colorHeight = 0.2 + 0.3 * (1 - exp(-(nRows - 1)/6))
  if (setLayout)
    layout(matrix(c(1:2), 2, 1), heights = c(1 - colorHeight,
                                             colorHeight))
  par(mar = c(0, marAll[2], marAll[3], marAll[4]))
  plot(dendro, labels = dendroLabels, cex = cex.dendroLabels,
       ...)
  if (addGuide)
    addGuideLines(dendro, count = if (guideAll)
      length(dendro$height) + 1
      else guideCount, hang = guideHang)
  if (!is.null(abHeight))
    abline(h = abHeight, col = abCol)
  par(mar = c(marAll[1], marAll[2], 0, marAll[4]))
  PlotConsensusBars(dendro, colors, groupLabels, cex.rowLabels = cex.colorLabels,
                    rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    cex.rowText = cex.rowText, rowWidths = rowWidths, addTextGuide = addTextGuide)
  if (saveMar)
    par(mar = oldMar)
}

#' PlotConsensusBars
#' 
#' Adapted from plotColorUnderTree found in the \pkg{WGCNA} package. This is
#' called by \code{\link{PlotStabilityDendro}} to generate the consensus bars
#' beneath the dendrogram.
#' 
#' @param dendro hclust object generated by \code{\link{RunCORE}}.
#' @param colors List of colours to use for the coloured bars.
#' @param rowLabels List of labels for colour bars.
#' @param rowWidths Width of the bars.
#' @param rowText Text to annotate bars.
#' @param rowTextAlignment Positioning of text - left, center or right.
#' @param rowTextIgnore Ignore row text.
#' @param textPositions Positoning of text.
#' @param addTextGuide TRUE or FALSE (Default).
#' @param cex.rowLabels 1 (Default).
#' @param cex.rowText 0.8 (Default).
#' @param ... Additional arguments to pass onto function.
PlotConsensusBars <- function (dendro, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, ...) {
  PlotOrderedColors(dendro$order, colors = colors, rowLabels = rowLabels,
                    rowWidths = rowWidths, rowText = rowText, rowTextAlignment = rowTextAlignment,
                    rowTextIgnore = rowTextIgnore, textPositions = textPositions,
                    addTextGuide = addTextGuide, cex.rowLabels = cex.rowLabels,
                    cex.rowText = cex.rowText, startAt = 0, ...)
}

#' PlotOrderedColors
#' 
#' Adapted from plotOrderedColors found in the \pkg{WGCNA} package. This is 
#' called by the \code{\link{PlotOrderedColors}} subfunction of the 
#' \code{\link{PlotStabilityDendro}} function.
#' 
#' @param order Order of colours/clustering result.
#' @param colors List of colours to use for each result.
#' @param rowLabels Set to NULL (Default).
#' @param rowWidths Set to NULL (Default).
#' @param rowText Set to NULL (Default)/
#' @param rowTextAlignment Can choose from "left", "center" and "right".
#' @param rowTextIgnore Set to NULL (Default).
#' @param textPositions Set to NULL (Default).
#' @param addTextGuide Set to TRUE (Default).
#' @param cex.rowLabels Set to 1 (Default).
#' @param cex.rowText Set to 0.8 (Default).
#' @param startAt Set to 0 (Default).
#' @param ... Additional arguments to pass on.
#' @importFrom grDevices colorRampPalette palette
#' @importFrom RColorBrewer brewer.pal
#' @importFrom graphics barplot strwidth rect lines strheight text
#' 
PlotOrderedColors <- function (order, colors, rowLabels = NULL, rowWidths = NULL,
                               rowText = NULL, rowTextAlignment = c("left", "center", "right"),
                               rowTextIgnore = NULL, textPositions = NULL, addTextGuide = TRUE,
                               cex.rowLabels = 1, cex.rowText = 0.8, startAt = 0, ...) {
  colors = as.matrix(colors)
  dimC = dim(colors)

  # Create a colour ramp
  gradient_palette <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(12, "Paired"))
  grDevices::palette(gradient_palette(max(colors)))
  if (is.null(rowLabels) & (length(dimnames(colors)[[2]]) ==
                            dimC[2]))
    rowLabels = colnames(colors)
  sAF = options("stringsAsFactors")
  options(stringsAsFactors = FALSE)
  on.exit(options(stringsAsFactors = sAF[[1]]), TRUE)
  nColorRows = dimC[2]
  if (length(order) != dimC[1])
    stop("ERROR: length of colors vector not compatible with number of objects in 'order'.")
  C = colors[order, , drop = FALSE]
  step = 1/(dimC[1] - 1 + 2 * startAt)
  graphics::barplot(height = 1, col = "white", border = FALSE, space = 0,
          axes = FALSE)
  charWidth = strwidth("W")/2
  if (!is.null(rowText)) {
    if (is.null(textPositions))
      textPositions = c(1:nColorRows)
    if (is.logical(textPositions))
      textPositions = c(1:nColorRows)[textPositions]
    nTextRows = length(textPositions)
  }
  else nTextRows = 0
  nRows = nColorRows + nTextRows
  ystep = 1/nRows
  if (is.null(rowWidths)) {
    rowWidths = rep(ystep, nColorRows + nTextRows)
  }
  else {
    if (length(rowWidths) != nRows)
      stop("plotOrderedColors: Length of 'rowWidths' must equal the total number of rows.")
    rowWidths = rowWidths/sum(rowWidths)
  }
  hasText = rep(0, nColorRows)
  hasText[textPositions] = 1
  csPosition = cumsum(c(0, hasText[-nColorRows]))
  colorRows = c(1:nColorRows) + csPosition
  rowType = rep(2, nRows)
  rowType[colorRows] = 1
  physicalTextRow = c(1:nRows)[rowType == 2]
  yBottom = c(0, cumsum(rowWidths[nRows:1]))
  yTop = cumsum(rowWidths[nRows:1])
  if (!is.null(rowText)) {
    rowTextAlignment = match.arg(rowTextAlignment)
    rowText = as.matrix(rowText)
    textPos = list()
    textPosY = list()
    textLevs = list()
    for (tr in 1:nTextRows) {
      charHeight = max(strheight(rowText[, tr], cex = cex.rowText))
      width1 = rowWidths[physicalTextRow[tr]]
      nCharFit = floor(width1/charHeight/1.7/par("lheight"))
      if (nCharFit < 1)
        stop("Rows are too narrow to fit text. Consider decreasing cex.rowText.")
      set = textPositions[tr]
      textLevs[[tr]] = sort(unique(rowText[, tr]))
      textLevs[[tr]] = textLevs[[tr]][!textLevs[[tr]] %in%
                                        rowTextIgnore]
      nLevs = length(textLevs[[tr]])
      textPos[[tr]] = rep(0, nLevs)
      orderedText = rowText[order, tr]
      for (cl in 1:nLevs) {
        ind = orderedText == textLevs[[tr]][cl]
        sind = ind[-1]
        ind1 = ind[-length(ind)]
        starts = c(if (ind[1]) 1 else NULL, which(!ind1 &
                                                    sind) + 1)
        ends = which(c(ind1 & !sind, ind[length(ind)]))
        if (length(starts) == 0)
          starts = 1
        if (length(ends) == 0)
          ends = length(ind)
        if (ends[1] < starts[1])
          starts = c(1, starts)
        if (ends[length(ends)] < starts[length(starts)])
          ends = c(ends, length(ind))
        lengths = ends - starts
        long = which.max(lengths)
        textPos[[tr]][cl] = switch(rowTextAlignment,
                                   left = starts[long], center = (starts[long] +
                                                                    ends[long])/2 + 0.5, right = ends[long] +
                                     1)
      }
      if (rowTextAlignment == "left") {
        yPos = seq(from = 1, to = nCharFit, by = 1)/(nCharFit +
                                                       1)
      }
      else {
        yPos = seq(from = nCharFit, to = 1, by = -1)/(nCharFit +
                                                        1)
      }
      textPosY[[tr]] = rep(yPos, ceiling(nLevs/nCharFit) +
                             5)[1:nLevs][rank(textPos[[tr]])]
    }
  }
  jIndex = nRows
  if (is.null(rowLabels))
    rowLabels = c(1:nColorRows)
  C[is.na(C)] = "grey"
  for (j in 1:nColorRows) {
    jj = jIndex
    ind = (1:dimC[1])
    xl = (ind - 1.5 + startAt) * step
    xr = (ind - 0.5 + startAt) * step
    yb = rep(yBottom[jj], dimC[1])
    yt = rep(yTop[jj], dimC[1])
    if (is.null(dim(C))) {
      print(as.character(C))
      rect(xl, yb, xr, yt, col = as.character(C), border = as.character(C))
    }
    else {
      rect(xl, yb, xr, yt, col = as.character(C[, j]),
           border = as.character(C[, j]))
    }
    text(rowLabels[j], pos = 2, x = -charWidth/2 + xl[1],
         y = (yBottom[jj] + yTop[jj])/2, cex = cex.rowLabels,
         xpd = TRUE)
    textRow = match(j, textPositions)
    if (is.finite(textRow)) {
      jIndex = jIndex - 1
      xt = (textPos[[textRow]] - 1.5) * step
      xt[xt < par("usr")[1]] = par("usr")[1]
      xt[xt > par("usr")[2]] = par("usr")[2]
      yt = yBottom[jIndex] + (yTop[jIndex] - yBottom[jIndex]) *
        (textPosY[[textRow]] + 1/(2 * nCharFit + 2))
      nt = length(textLevs[[textRow]])
      if (addTextGuide)
        for (l in 1:nt) lines(c(xt[l], xt[l]), c(yt[l],
                                                 yTop[jIndex]), col = "darkgrey", lty = 3)
      textAdj = c(0, 0.5, 1)[match(rowTextAlignment, c("left",
                                                       "center", "right"))]
      text(textLevs[[textRow]], x = xt, y = yt, adj = c(textAdj,
                                                        1), xpd = TRUE, cex = cex.rowText)
    }
    jIndex = jIndex - 1
  }
  for (j in 0:(nColorRows + nTextRows)) lines(x = c(0, 1),
                                              y = c(yBottom[j + 1], yBottom[j + 1]))
}

#' PlotStabilityDendro
#'
#' Generate a dendrogram with coloured bars representing each clustering result
#' below. This function is derived from the plotDendroAndColors function found
#' in the \pkg{WGCNA} package.
#' 
#' @param object An \code{\linkS4class{EMSet}} that has undergone clustering.
#' @examples
#' \dontrun{
#' pdf("MyStabilityDendrogram.pdf")
#' PlotStabilityDendro(em.set)
#' dev.off()
#' }
#' @export
#'
PlotStabilityDendro <- function(object){
  # Check that the user has done the required steps.
  if (length(object@Clusters) == 0){
    stop("Please run RunCORE on this object before using this function.")
  }

  # Get the variables
  dendro <- object@Clusters$Hclust
  colours <- object@Clusters$ClusteringMatrix

  # Plotting function
  print(PlotClusterDendro(dendro, colours))
}


#' PlotMDS
#'
#' Generates a Multi-Dimensional Scaling (MDS) plot.
#'
#' @param object An \code{\linkS4class{EMSet}} that has undergone clustering with 
#' \code{\link{RunCORE}}.
#' @param PCA If true, use PCA-reduced matrix to generate MDS plot.
#' @param dim1 Which dimension to plot on the x-axis.
#' @param dim2 Which dimension to plot on the y-axis.
#' @param condition (Optional) Name of the condition in Cell Identifiers that 
#' describe a set of conditions you would like to colour cells by.
#' @return A ggplot glob that contains a scatter plot.
#' @examples
#'  \dontrun{
#'  library(ggplot2)
#'  my_mds_plot <- PlotMDS(em.set, PCA = TRUE, dim1 = 3, dim2 = 4, 
#'  condition = "cluster") + ggtitle("My MDS Plot")
#'  }
#' @importFrom stats dist cmdscale
#' @importFrom ggplot2 ggplot aes geom_point labs
#' @export
#'
PlotMDS <- function(object, PCA = FALSE, dim1 = 1, dim2 = 2, condition = NULL){
  if (class(object) != "EMSet"){
    stop("Please supply an EMSet object.")
  }

  # Check the column has been defined
  if (!is.null(condition)){
    if (is.null(object@CellInformation[ ,condition])){
      stop("Please ensure your specified condition exists.")
    } else{
      condition.list <- object@CellInformation[, condition]
      names(condition.list) <- object@CellInformation[,1]
    }
  } else{
    condition.list <- NULL
  }

  # Retrieve distance matrix
  if (PCA){
    # Stop if user hasn't run PCA.
    if (length(object@PCA) == 0){
      stop("Please use RunPCA on this object before using the PCA argument for this function.")
    }

    # Retrieve distance matrix
    if (length(object@Clusters) > 0){
      distance.matrix <- object@Clusters$DistanceMatrix
    } else{
      pca.matrix <- object@PCA$PCA
      if (ncol(pca.matrix) >= 20){
        n <- 20
        pca.matrix <- pca.matrix[,1:n]
      } else{
        n <- ncol(pca.matrix)
      }
      print(sprintf("Calculating distance matrix from top %s PCAs..."), n)
      distance.matrix <- stats::dist(pca.matrix)
    }
  } else{
    print("Calculating distance matrix from expression data...")
    expression.matrix <- GetExpressionMatrix(object, "matrix")
    gene.variance <- CalcRowVariance(expression.matrix)
    names(gene.variance) <- rownames(expression.matrix)
    sorted.gene.variance <- gene.variance[order(unlist(gene.variance), decreasing = TRUE)]
    top.genes <- sorted.gene.variance[1:1000]

    # Subsetting matrix
    subset.matrix <- expression.matrix[names(top.genes), ]
    subset.matrix <- Matrix::t(subset.matrix)
    # Create distance matrix
    distance.matrix <- stats::dist(subset.matrix)
  }

  # Scale matrix
  print("Running cmdscale...")
  mds.matrix <-stats::cmdscale(distance.matrix, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE)
  print("Cmdscale complete! Processing scaled data...")
  mds.matrix <- as.data.frame(mds.matrix)
  colnames(mds.matrix) <- c("Dim1", "Dim2")

  print("Generating MDS plot...")
  if (!is.null(condition.list) && length(condition.list) > 0){
    mds.matrix$condition <- unlist(condition.list)
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2, col=factor(condition))) + ggplot2::geom_point(alpha = 0.5) + ggplot2::labs(colour = condition)
  } else{
    mds.plot <- ggplot2::ggplot(mds.matrix, ggplot2::aes(Dim1,Dim2)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }

  return(mds.plot)
}

#' PlotTSNE
#'
#' Generates a 2D TSNE plot. As this function requires the reduction of the
#' expression matrix by TSNE, it takes longer to run in comparison to the other
#' reduced dimension plots.
#' 
#' If you just require a TSNE matrix, you can generate this with the
#' \code{\link{RunTSNE}} function.
#' 
#' @param object An \code{\linkS4class{EMSet}}.
#' @param PCA Set to FALSE to not use PCA-reduced values.
#' @param condition (Optional) Name of the column in CellIdentifiers that 
#' describe a set of conditions you would like to colour cells by.
#' @param seed (Optional) Set to a specific value for reproducible TSNE plots.
#' @param perplexity (Optional) Numeric; perplexity parameter.
#' @param theta (Optional) Numeric; Speed/accuracy trade-off (increase for less 
#' accuracy).
#' @return A ggplot glob that contains a scatter plot.
#' @examples
#' \dontrun{
#' library(ggplot2)
#' my_tsne_plot <- PlotTSNE(em.set, PCA = TRUE, condition = "cluster", seed = 1)  
#' my_tsne_plot <- my_tsne_plot + ggtitle("My TSNE Plot")
#' }
#' @importFrom ggplot2 ggplot aes geom_point labs
#' @export
#'
PlotTSNE <- function(object, PCA = TRUE, condition = NULL, seed = 0, 
                     perplexity = 30, theta = 0.5){
  # Input checks
  if (class(object) != "EMSet"){
    stop("Please supply an EMSet to this function.")
  }

  # Check the column has been defined
  if (!is.null(condition)){
    if (is.null(object@CellInformation[ , condition])){
      stop("Please ensure your specified condition exists.")
    } else{
      condition.list <- object@CellInformation[, condition]
      names(condition.list) <- object@CellInformation[,1]
    }
  } else{
    condition.list <- NULL
  }

  if(PCA){
    if (!(length(object@PCA) > 0)){
      stop("Please reduce this dataset with RunPCA before using this function.")
    } else{
      pca.barcodes <- rownames(object@PCA$PCA)
      condition.list <- condition.list[pca.barcodes]
      if (!(length(condition.list) > 0)){
        stop("Please ensure all cell identifiers specified in the condition list are in the EMSet.")
      }
    }
  } else{
    if (!all(names(condition.list) %in% object@ExpressionMatrix)){
      stop("Please ensure all cell identifiers specified in the condition list are in the EMSet.")
    }
  }

  # Run TSNE in 2D
  tsne.df <- RunTSNE(object, PCA = PCA, dimensions = 2, seed = seed, perplexity = perplexity, theta = theta)

  # Generate Plots
  if (!is.null(condition.list) && length(condition.list) > 0){
    tsne.df$conditions <- as.factor(unlist(condition.list))
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)), alpha = 0.5) + ggplot2::labs(colour = condition)
  } else{
    tsne.plot <- ggplot2::ggplot(tsne.df, ggplot2::aes(X1, X2)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }

  return(tsne.plot)
}

#' PlotPCA
#'
#' Plot two principal components (PCs) on a scatter plot. This plot corresponds
#' more closely to the distance between points and therefore is good to use
#' to review the effectiveness of clustering by the CORE algorithm.
#'
#' @param object An \code{\linkS4class{EMSet}} object that has undergone PCA.
#' @param dim1 Principal component to plot on the x-axis.
#' @param dim2 Principal component to plot on the y-axis.
#' @param condition (Optional) Name of the column in CellIdentifiers that 
#' describe a set of conditions you would like to colour cells by.
#' @return A ggplot glob that contains a scatter plot.
#' @examples
#' \dontrun{
#' library(ggplot2)
#' my_pca_plot <- PlotPCA(em.set, dim1 = 1, dim2 = 2,  condition = "cluster")  
#' my_pca_plot <- my_pca_plot + ggtitle("My PCA Plot")
#' }
#' @importFrom ggplot2 ggplot aes geom_point labs
#' @export
#'
PlotPCA <- function(object, dim1 = 1, dim2 = 2, condition = NULL){
  if(length(object@PCA) == 0){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  # Check the column has been defined
  if (!is.null(condition)){
    if (is.null(object@CellInformation[ , condition])){
      stop("Please ensure your specified column exists.")
    } else{
      condition.list <- object@CellInformation[, condition]
      names(condition.list) <- object@CellInformation[,1]
    }
  } else{
    condition.list <- NULL
  }

  # Extract dimensions to plot
  pca.matrix <- object@PCA$PCA
  plot.matrix <- pca.matrix[, c(dim1, dim2)]
  colnames(plot.matrix) <- c("x", "y")

  if (!is.null(condition.list) && length(condition.list) > 0){
    plot.matrix$conditions <- as.factor(unlist(condition.list))
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point(ggplot2::aes(colour = factor(conditions)), alpha = 0.5) + ggplot2::labs(colour = condition)
  } else{
    pca.plot <- ggplot2::ggplot(plot.matrix, ggplot2::aes(x, y)) + ggplot2::geom_point(show.legend = FALSE, alpha = 0.5)
  }

  return(pca.plot)
}

#' PlotPCAVariance
#'
#' Generates a scree plot. The principal components (PCs) are sorted from 
#' largest percent variance to the smallest percent variance. This plot is
#' for determining the optimal number of PCs to retain for further analysis.
#'
#' @param object An \code{\linkS4class{EMSet}} that has undergone PCA.
#' @param n Number of PCs to view on the plot.
#' @return A ggplot2 glob that contains a scatter qplot.
#' @examples
#' \dontrun{
#' # Run PCA on an EMSet
#' pca_set <- RunPCA(em.set)
#' 
#' # Review first 100 dimensions on the scree plot
#' print(PlotPCAVariance(pca_set, n = 100))
#' }
#' @importFrom ggplot2 qplot
#' @export
#'
PlotPCAVariance <- function(object, n = 100){
  if(is.null(object@PCA$PCAPercentVariance)){
    stop("Please supply an object that has undergone PCA reduction.")
  }

  pca.obj <- ggplot2::qplot(y=object@PCA$PCAPercentVariance[1:n], x=1:n, geom="point", xlab="Principal Component (PC)", ylab="Variance", main="Percent Variance per PC")
  return(pca.obj)
}

#' PlotNormalisationQC
#'
#' Generates a series of plots comparing an un-normalised and a normalised 
#' \code{\linkS4class{EMSet}}.
#'
#' @param original An un-normalised \code{\linkS4class{EMSet}}.
#' @param normalised A normalised \code{\linkS4class{EMSet}}.
#' @param gene.list OPTIONAL: A list of genes to plot expression levels for. 
#' If not defined, \pkg{ascend} will choose a gene at random. Good candidates
#' are MALAT1 and GAPDH.
#' @return A list containing the following plots:
#' \itemize{
#' \item{Library size histograms.}
#' \item{Scatter boxplots for selected genes.}
#' \item{Scatter boxplots for each gene.}
#' }
#' @examples
#' \dontrun{
#' # Normalise dataset using relative log expression (RLE)
#' norm_set <- NormaliseByRLE(em.set)
#' 
#' # Generate QC plots for normalisation
#' norm_plots <- PlotNormalisationQC(original = em.set, normalised = norm_set,
#' gene.list = c("MALAT1", "GAPDH")
#' )
#' 
#' # Output plots to PDF
#' PlotPDF(norm_plots, "NormQC.pdf")
#' }
#' @importFrom ggplot2 aes geom_histogram xlab ylab ggtitle ggplot_build qplot geom_boxplot scale_y_continuous labs theme element_blank
#' @importFrom utils stack
#' @export
#'
PlotNormalisationQC <- function(original = NULL, normalised = NULL, gene.list = list()) {
  # Insert Check For Normalisation
  if(!is.null(original@Log$NormalisationMethod)){
    stop("Please supply an un-normalised EMSet object.")
  }

  if(is.null(normalised@Log$NormalisationMethod)){
    stop("Please supply a normalised EMSet object.")
  }

  # Set output
  output.list <- list()

  # Get metrics we need from old and new object
  print("Retrieving data from EMSets...")
  matrix.1 <- GetExpressionMatrix(original, "data.frame")
  matrix.2 <- GetExpressionMatrix(normalised, "data.frame")

  # As normalisation removes cells and genes, trim original matrix.
  common.rows <- intersect(rownames(matrix.1), rownames(matrix.2))
  common.cols <- intersect(colnames(matrix.1), colnames(matrix.1))
  matrix.1 <- matrix.1[common.rows, common.cols]

  # Retrieve library sizes
  libsize.1 <- original@Metrics$TotalCounts
  libsize.2 <- normalised@Metrics$TotalCounts

  # Retrieve feature counts
  cells.per.gene.1 <- original@Metrics$CellsPerGene
  cells.per.gene.2 <- normalised@Metrics$CellsPerGene

  # Generate histogram
  print("Plotting libsize histograms...")
  # Combine libsizes
  libsize.df.1 <- data.frame(Libsize = libsize.1, Dataset=rep("Original", length(libsize.1)))
  libsize.df.2 <- data.frame(Libsize = libsize.2, Dataset=rep("Normalised", length(libsize.2)))

  # Get largest library size
  max.libsize <- max(c(libsize.1, libsize.2))
  libsize.df <- rbind(libsize.df.1, libsize.df.2)
  libsize.hist <- ggplot2::ggplot(libsize.df, ggplot2::aes(Libsize, fill = Dataset)) + ggplot2::geom_histogram(alpha = 0.5, position = "identity", binwidth = 1000) + ggplot2::xlab("Library size") + ggplot2::ylab("Number of cells") + ggplot2::ggtitle("Library sizes across cells")
  max.counts <- max(ggplot2::ggplot_build(libsize.hist)$data[[1]]$count)

  libsize.hist.1 <- ggplot2::qplot(libsize.1, xlim = c(0, max.libsize * 1.1), ylim = c(0, max.counts * 1.1), main = "Before normalisation", xlab = "Library size", ylab = "Number of cells", binwidth = 1000)
  libsize.hist.2 <- ggplot2::qplot(libsize.2, xlim = c(0, max.libsize * 1.1), ylim = c(0, max.counts * 1.1), main = "After normalisation", xlab = "Library size", ylab = "Number of cells", binwidth = 1000)

  #output.libsize.hist <- gridExtra::grid.arrange(libsize.hist.1, libsize.hist.2, ncol = 2)
  output.list <- c(output.list, list(Libsize=list(Original = libsize.hist.1, Normalised = libsize.hist.2)))

  # Remove zero counts
  matrix.1 <- matrix.1[which(rowSums(matrix.1) > 0),]
  matrix.2 <- matrix.2[which(rowSums(matrix.2) > 0),]

  # Plot scatter for housekeeping genes
  if(length(gene.list) > 0){
    gene.scatter.list <- list()
    for (gene in gene.list){
      # Check if there are any counts
      gene.counts.1 <- matrix.1[gene, ][which(matrix.1[gene, ] > 0)]
      gene.counts.2 <- matrix.2[gene, ][which(matrix.2[gene, ] > 0)]

      if((length(gene.counts.1) > 0) && (length(gene.counts.2) > 0)){
        print(sprintf("Plotting %s expression...", gene))

        # Get ylim
        ylim.1 <- max(gene.counts.1)
        ylim.2 <- max(gene.counts.2)
        ylim.max <- (max(ylim.1, ylim.2)) * 1.1

        gene.scatter.1 <- ggplot2::qplot(x = 1:length(gene.counts.1), y = unlist(gene.counts.1), geom="point", alpha=0.2, main=sprintf('Expression of %s (Before normalisation)', gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
        gene.scatter.2 <- ggplot2::qplot(x = 1:length(gene.counts.2), y = unlist(gene.counts.2), geom="point", alpha=0.2, main=sprintf('Expression of %s (After normalisation)', gene), xlab="Cells", ylab="Gene expression", ylim = c(0, ylim.max))
        gene.scatter.list[[gene]] <- list(Original = gene.scatter.1, Normalised = gene.scatter.2)
      }
    }
    output.list <- c(output.list, list(GeneScatterPlots=gene.scatter.list))}
  else{
    # While loop - look for a suitable gene
    success <- FALSE
    while (!success){
      gene <- sample(rownames(matrix.2), 1)
      gene.counts.1 <- matrix.1[gene,][which(matrix.1[gene, ] > 0)]
      gene.counts.2 <- matrix.2[gene,][which(matrix.2[gene, ] > 0)]
      success <- (length(gene.counts.1) > 10) && (length(gene.counts.2) > 10)
    }

    # Found a gene!
    print(sprintf("Plotting %s expression...", gene))
    # Get ylim
    ylim.1 <- max(gene.counts.1)
    ylim.2<- max(gene.counts.2)
    ylim.max <- max(ylim.1, ylim.2) * 1.1

    gene.scatter.1 <- ggplot2::qplot(x = 1:length(gene.counts.1), y = unlist(gene.counts.1), geom="point", alpha=0.2, main = sprintf("Expression of %s (Before normalisation)", gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
    gene.scatter.2 <- ggplot2::qplot(x = 1:length(gene.counts.2), y = unlist(gene.counts.2), geom="point", alpha=0.2, main = sprintf("Expression of %s (After normalisation)", gene), xlab="Cells" , ylab="Gene expression", ylim = c(0, ylim.max))
    output.list <- c(output.list, list(GeneScatterPlots = list(Original = gene.scatter.1, Normalised = gene.scatter.2)))
  }

  # Generate box plots
  print("Plotting gene expression box plots...")
  # Generate box plots
  print("Plotting gene expression box plots...")
  ordered.1 <- matrix.1[order(rowSums(matrix.1), decreasing=T),]
  ordered.2 <- matrix.2[order(rowSums(matrix.2), decreasing=T),]

  ordered.1 <- utils::stack(ordered.1[,1:100])
  ordered.2 <- utils::stack(ordered.2[,1:100])

  ylim <- max(ordered.1$values[1], ordered.2$values[1])

  boxplot.1 <- ggplot2::ggplot(ordered.1, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot() + ggplot2::scale_y_continuous(limits = c(0, ylim*1.1))
  boxplot.2 <- ggplot2::ggplot(ordered.2, ggplot2::aes(x=ind, y=values)) + ggplot2::geom_boxplot() + ggplot2::scale_y_continuous(limits = c(0, ylim*1.1))

  boxplot.1 <- boxplot.1 + ggplot2::labs(title='Gene expression (Before normalisation)',  y='Gene expression', x='Cells')
  boxplot.2 <- boxplot.2 + ggplot2::labs(title='Gene expression (After normalisation)',  y='Gene expression', x='Cells')

  boxplot.1 <- boxplot.1 + ggplot2::theme(axis.text.x = ggplot2::element_blank())
  boxplot.2 <- boxplot.2 + ggplot2::theme(axis.text.x = ggplot2::element_blank())

  print("Plots complete!")

  # Return a list of output
  output.list <- c(output.list, list(GeneExpressionBoxplot = list(Original = boxplot.1, Normalised = boxplot.2)))
  return(output.list)
}


#' z_theme
#' 
#' From perceptions - https://github.com/zonination/perceptions. This function 
#' sets the colour themes for use with the \code{\link{PlotTopGeneExpression}} 
#' function.
#'  
#' @importFrom RColorBrewer brewer.pal
#' @importFrom ggplot2 theme_bw theme element_rect element_line element_blank element_text 
#' 
z_theme <- function() {
  palette <- RColorBrewer::brewer.pal("Greys", n=9)
  color.background = palette[1]
  color.grid.major = palette[5]
  color.axis.text = palette[7]
  color.axis.title = palette[7]
  color.title = palette[8]
  # Begin construction of chart
  ggplot2::theme_bw(base_size=9) +
    # Set the entire chart region to a light gray color
    ggplot2::theme(panel.background = ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(plot.background= ggplot2::element_rect(fill=color.background, color=color.background)) +
    ggplot2::theme(panel.border= ggplot2::element_rect(color=color.background)) +
    # Format the grid
    ggplot2::theme(panel.grid.major= ggplot2::element_line(color=color.grid.major,size=.25)) +
    ggplot2::theme(panel.grid.minor= ggplot2::element_blank()) +
    ggplot2::theme(axis.ticks= ggplot2::element_blank()) +
    # Format the legend, but hide by default
    ggplot2::theme(legend.position="none") +
    ggplot2::theme(legend.background = ggplot2::element_rect(fill=color.background)) +
    ggplot2::theme(legend.text = ggplot2::element_text(size=7,color=color.axis.title)) +
    # Set title and axis labels, and format these and tick marks
    ggplot2::theme(plot.title = ggplot2::element_text(color=color.title, size=20, vjust=1.25)) +
    ggplot2::theme(axis.text.x = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.text.y = ggplot2::element_text(size=14, color=color.axis.text)) +
    ggplot2::theme(axis.title.x = ggplot2::element_text(size=16, color=color.axis.title, vjust=0)) +
    ggplot2::theme(axis.title.y = ggplot2::element_text(size=16, color=color.axis.title, vjust=1.25))
}

#' PlotTopGenesPerSample
#'
#' Generates a violin/beeswarm plot of top genes per sample. This is called by
#' the \code{\link{PlotGeneralQC}} function.
#'
#' @param object An \code{\linkS4class{EMSet}} object.
#' @importFrom Matrix colSums
#' @importFrom ggplot2 ggplot scale_colour_gradient aes geom_violin scale_x_discrete xlab ylab ggtitle
#' @importFrom ggbeeswarm geom_quasirandom 
#' @export
#'
PlotTopGenesPerSample <- function(object){
  # Generate tidy data
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  top.gene.list <- object@Metrics$TopGeneList
  metrics <- object@Metrics

  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  batch.names <- unique(present.batches)

  # Prepare Top 500
  top.500.gene.list <- top.gene.list[1:500]
  subset.500.mtx <- expression.matrix[top.500.gene.list,]
  top.500.percentage <- 100 * colSums(subset.500.mtx)/colSums(expression.matrix)

  # Prepare Top 100
  top.100.gene.list <- top.gene.list[1:100]
  subset.100.mtx <- expression.matrix[top.100.gene.list,]
  top.100.percentage <- 100 * colSums(subset.100.mtx)/colSums(expression.matrix)

  ## Tidy dataframe
  combined.data <- list(Percentage500 = top.500.percentage, Percentage100 = top.100.percentage, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentage500, colour = Percentage100))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotLibrarySizesPerSample
#'
#' Generates a violin-beeswarm plot of library sizes per sample. This is called 
#' by the \code{\link{PlotGeneralQC}} function.
#'
#' @param object An \code{\linkS4class{EMSet}} object.
#' @importFrom ggplot2 ggplot scale_colour_gradient aes geom_violin scale_x_discrete xlab ylab ggtitle
#' @importFrom ggbeeswarm geom_quasirandom 
#' @export
#'
PlotLibrarySizesPerSample <- function(object){
  # Tidy data to feed into ggplot
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  total.counts <- metrics$TotalCounts[present.barcodes]
  total.features <- metrics$TotalFeatureCountsPerCell[present.barcodes]
  batch.names <- unique(present.batches)

  ## Tidy dataframe
  combined.data <- list(TotalCounts = total.counts, FeatureCounts = total.features, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # ggplot
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = TotalCounts, colour = FeatureCounts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("Total mapped reads per cell")
  control.plot <- control.plot + ggplot2::ggtitle("Total mapped reads and genes per sample")

  remove(expression.matrix)
  return(control.plot)
}

#' PlotControlPercentagesPerSample
#'
#' Generates a violin/beeswarm plot of percentage of control expression per 
#' sample. Called by \code{\link{PlotGeneralQC}}.
#' 
#' @param object An \code{\linkS4class{EMSet}} object.
#' @param control.name Name of the control you would like to plot.
#' @importFrom ggplot2 ggplot scale_colour_gradient aes geom_violin scale_x_discrete xlab ylab ggtitle
#' @importFrom ggbeeswarm geom_quasirandom 
#' @export
#'
PlotControlPercentagesPerSample <- function(object, control.name){
  # Tidy data to feed into ggplot
  ## Load data from the object
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  cell.information <- object@CellInformation
  present.barcodes <- colnames(expression.matrix)
  metrics <- object@Metrics

  ## Subset the data
  present.batches <- unlist(cell.information[,2][cell.information[,1] %in% present.barcodes])
  subset.control.percentages <- metrics$PercentageTotalCounts[[control.name]][present.barcodes]
  subset.counts <- metrics$ControlTranscriptCounts[[control.name]][present.barcodes]
  batch.names <- unique(present.batches)

  ## Combine into a tidy dataframe
  combined.data <- list(Percentages = subset.control.percentages, Counts = subset.counts, BatchInfo = present.batches)
  combined.df <- as.data.frame(combined.data)

  # Use ggplot to generate a violin/beeswarm plot
  ## Colour palette
  gradient.ramp <- ggplot2::scale_colour_gradient(low="#001b7f", high="#f1d351")
  plot.title <- sprintf("Percentage of reads mapped to %s genes", control.name)

  ## ggplot call
  control.plot <- ggplot2::ggplot(combined.df, ggplot2::aes(x = factor(BatchInfo), y = Percentages, colour = Counts))
  control.plot <- control.plot + ggplot2::geom_violin(size = 1, scale = "width", colour = NA) + ggbeeswarm::geom_quasirandom(shape = 16, size=5, alpha=0.5, dodge.width=0.5)
  control.plot <- control.plot + gradient.ramp + ggplot2::scale_x_discrete(limits = batch.names) + ggplot2::xlab("Sample") + ggplot2::ylab("% Reads")  + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(control.plot)
}


#' PlotTopGeneExpression
#'
#' Generates a boxplot using \link[ggplot2]{geom_boxplot} of the most expressed 
#' genes in the dataset, in a range defined by the user.
#' 
#' @param object A EMSet object.
#' @param n Number of genes to be plotted.
#' @param controls Include control genes in plot (Default: TRUE).
#' 
#' @return A ggplot glob containing a box scatter plot that represents the 
#' expression of the most highly expressed genes.
#' @examples
#' \dontrun{
#' top_gene_expression <- PlotTopGeneExpression(em.set, n = 20, controls = FALSE)
#' }
#' @importFrom reshape2 melt
#' @importFrom ggplot2 ggplot aes geom_boxplot coord_flip xlab ylab ggtitle
#' @export
#'
PlotTopGeneExpression <- function(object, n = 50, controls = TRUE){
  # Prep data to feed in
  if(!controls){
    control.list <- object@Controls
    if(all(names(control.list) %in% c("Mt", "Rb"))){
      object <- ExcludeControl(object, "Mt")
      object <- ExcludeControl(object, "Rb")
    }
  }

  plot.title <- sprintf("Top %i Expressed Genes", n)
  expression.matrix <- GetExpressionMatrix(object, "data.frame")
  counts.per.gene <- object@Metrics$CountsPerGene
  total.expression <- object@Metrics$TotalExpression
  top.gene.list <- object@Metrics$TopGeneList[1:n]

  subset.exprs.mtx <- expression.matrix[top.gene.list,]
  sorted.counts.per.gene <- sort(counts.per.gene, decreasing = TRUE)
  top.genes.percentage <- 100 * sum(sorted.counts.per.gene[1:n])/total.expression
  top.gene.expression.per.cell <- (100 * subset.exprs.mtx)/colSums(expression.matrix)

  transposed.gene.expression <- t(top.gene.expression.per.cell)
  melted.gene.expression <- reshape2::melt(as.matrix(transposed.gene.expression))
  melted.gene.expression$Var2 <- factor(melted.gene.expression$Var2, levels = (rev(top.gene.list)))
  ggplot.obj <- ggplot2::ggplot(melted.gene.expression, ggplot2::aes(y = value,x = Var2)) + ggplot2::geom_boxplot(ggplot2::aes(fill=Var2), alpha=.5, outlier.colour = NULL)
  ggplot.obj <- ggplot.obj + ggplot2::coord_flip() + z_theme() + ggplot2::xlab("Gene") + ggplot2::ylab("% Expression") + ggplot2::ggtitle(plot.title)

  remove(expression.matrix)
  return(ggplot.obj)
}

#' PlotGeneralQC
#'
#' This function generates a series of plots that can be used to assess the
#' present quality of an EMSet.
#' 
#' The plots are as follows:
#' \itemize{
#' \item{\strong{Library Size}: A histogram depicting the distribution of 
#' library sizes across the dataset.}
#' \item{\strong{Average Gene Count}: A histogram depicting number of cells vs 
#' mean gene expression.}
#' \item{\strong{Average Gene Count (Log2)}: A histogram depicting number of 
#' cells vs Log2 mean gene expression.}
#' \item{\strong{Average Gene Count (Log10)}: A histogram depicting number of 
#' cells vs Log2 mean gene expression.}
#' \item{\strong{Log 10 Average Gene Count (Smooth Scatter)}: Smooth scatter 
#' plot of number of cells vs Log10 mean gene expression.}
#' \item{\strong{Top Genes Per Sample}: Violin/beehive plots depicting 
#' proportion of top genes per sample.}
#' \item{\strong{Top Gene Expression}: Boxplots depicting top 50 genes in terms 
#' of expression.}
#' }

#' If controls are defined, two additional plots are generated:
#' \itemize{
#' \item{\strong{Percentage Control Expression}: Histograms depicting number of 
#' cells with the contribution of control genes as a percentage of total counts.}
#' \item{\strong{Proportion of Control Expression}: Violin/beehive plots for 
#' each sample and control, depicting the proportion of controls to total 
#' expression.}
#' }
#' 
#' @param object An \code{\linkS4class{EMSet}} object.
#' @return A list of ggplot globs
#' @examples
#' \dontrun{
#' # Create a new EMSet
#' em.set <- NewEMSet(ExpressionMatrix = my_matrix)
#' 
#' # Assess quality of data by generating plots with PlotGeneralQC
#' raw.qc.plots <- PlotGeneralQC(em.set)
#' 
#' # Print QC plots out to a PDF file
#' PlotPDF(raw.qc.plots, "GeneralQCPlots.pdf")
#' }
#' @importFrom ggplot2 ggplot qplot aes theme_bw geom_histogram ggtitle xlab ylab ggtitle
#' @importFrom graphics smoothScatter
#' @export
#'
PlotGeneralQC <- function(object){
  output.list <- list()
  # General Plots
  # 1. Plot library sizes and expressed gene histograms
  print("Plotting Total Count and Library Size...")
  libsize.plot <- ggplot2::qplot(object@Metrics$TotalCounts, geom="histogram", main="Distribution of library sizes across dataset", xlab="Library size", ylab="Number of cells", binwidth=1000) + ggplot2::theme_bw()
  output.list[["LibSize"]] <- libsize.plot

  print("Plotting Average Counts...")
  smooth.scatter <- graphics::smoothScatter(log10(object@Metrics$AverageCounts), object@Metrics$CellsPerGene, xlab=expression(Log[10]~"Average Count"),ylab="Number of expressing cells", main = "Log 10 Average gene expression across cells")
  average.gene.count <- ggplot2::qplot(object@Metrics$AverageCounts, xlab="Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 10) + ggplot2::theme_bw()
  log2.average.count <- ggplot2::qplot(log2(object@Metrics$AverageCounts)[!is.infinite(log2(object@Metrics$AverageCounts))], geom="histogram", xlab=Log[2]~"Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 1) + ggplot2::theme_bw()
  log10.average.gene.count <- ggplot2::qplot(log10(object@Metrics$AverageCounts)[!is.infinite(log10(object@Metrics$AverageCounts))], geom="histogram", xlab=Log[10]~"Average Transcript Count", ylab="Number of genes", main="Average Transcript Count of Genes", binwidth = 0.1) + ggplot2::theme_bw()
  
  output.list[["AverageGeneCount"]] <- average.gene.count
  output.list[["Log2AverageGeneCount"]] <- log2.average.count
  output.list[["Log10AverageGeneCount"]] <- log10.average.gene.count
  output.list[["AverageCountSmoothScatter"]] <- smooth.scatter
  
  # 2. Average Counts
  if (object@Log$Controls){
    # Plots that need controls
    # 1. Plot library sizes and expressed gene histograms
    feature.counts.per.cell <- ggplot2::qplot(object@Metrics$TotalFeatureCountsPerCell, geom="histogram", xlab="Number of expressed genes", main="Number of expressed genes across cells", ylab="Number of cells", binwidth = 250) + ggplot2::theme_bw()
    output.list[["FeatureCountsPerCell"]] <- feature.counts.per.cell

    # 2. Proportion of Controls
    print("Plotting Proportion of Control Histograms...")
    percentage.total.plots <- list()
    for (control.name in names(object@Metrics$PercentageTotalCounts)){
      xlab.string <- paste0("%", sprintf("%s proportion ", control.name))
      title.string <- sprintf("Proportion of control: %s", control.name)
      percentage.total.counts <- as.data.frame(object@Metrics$PercentageTotalCounts[[control.name]])
      colnames(percentage.total.counts) <- c("Percentage")
      pct.hist <- ggplot2::ggplot(percentage.total.counts, ggplot2::aes(Percentage)) + ggplot2::geom_histogram(binwidth = 1) + ggplot2::ggtitle(title.string) + ggplot2::theme_bw()
      pct.hist <- pct.hist + ggplot2::xlab(xlab.string) + ggplot2::ylab("Number of cells") + ggplot2::ggtitle(title.string)
      percentage.total.plots[[control.name]] <- pct.hist
    }

    # 6. Plot Controls Per Sample
    print("Using ggplot2 to plot Control Percentages...")
    percentage.sample.list <- list()
    for (control.name in names(object@Controls)){
      control.pct.plot <- PlotControlPercentagesPerSample(object, control.name)
      percentage.sample.list[[control.name]] <- control.pct.plot
    }

    output.list[["ControlPercentageTotalCounts"]] <- percentage.total.plots
    output.list[["ControlPercentageSampleCounts"]] <- percentage.sample.list

    # 4. Plot Library Sizes per Sample
    print("Using ggplot2 to plot Library Sizes Per Sample...")
    library.size.plot <- PlotLibrarySizesPerSample(object)
    output.list[["LibSizePerSample"]] <- library.size.plot

  }


  # 5. Plot Genes per Sample
  print("Using ggplot2 to plot Top Genes Per Sample...")
  genes.per.sample.plot <- PlotTopGenesPerSample(object)
  output.list[["TopGenesPerSample"]] <- genes.per.sample.plot

  # 7. Plot Top Genes
  print("Using ggplot2 to plot Top Gene Expression...")
  top.genes.plot <- PlotTopGeneExpression(object)
  output.list[["TopGenes"]] <- top.genes.plot
  return(output.list)
}
