#' PlotPDF
#'
#' Takes a list of plots generated by \pkg{ascend} and prints them to PDF.
#' @param plot.list A list of plots generated by \pkg{ascend}
#' @param filename Name of the file you would like to output to
#' @param width Width of the PDF
#' @param height Height of the PDF
#' @export
#'
PlotPDF <- function(plot.list, filename = NULL, width = 11, height = 8.5){
  if (missing(filename)){
    stop("Please specify a filename.")
  }

  # Set file to print out to
  pdf(filename, width = width, height = height)
  for (plot.name in names(plot.list)){
    plot <- plot.list[[plot.name]]
    if (length(class(plot)) == 1){
      if (is.list(plot)){
        for (x in plot){
          print(x)
        }
      }
    } else{
      print(plot)
    }
  }
  dev.off()
}

# Unlog matrix - required if object was normalised with scran's deconvolution method
#' UnLog2Matrix
#'
#' Converts count values of a matrix that had undergone normalisation via scran's deconvolution method.
#' @param expression.matrix An expression.matrix
#'
UnLog2Matrix <- function(expression.matrix){
  unlog.matrix <-apply(expression.matrix, 1, function(x) 2^x)
  unlog.matrix.sub.1 <- unlog.matrix -1
  unlog.matrix.sub.1[unlog.matrix.sub.1 < 0] <- 0
  unlog.matrix.pos <- Matrix::t(unlog.matrix.sub.1)
  return(unlog.matrix.pos)
}

#' ChunkMatrix
#'
#' Chunks a matrix randomly - either along rows or columns
#' @param expression.matrix An expression matrix to chunk
#' @param axis Specify either 0 (rows) or 1 (columns)
#' @param chunks Number of chunks you would like to break the matrix into
#' @export
#'
ChunkMatrix <- function(expression.matrix, axis=0, chunks = 1){
  if(missing(axis)){
    stop("Please specify axis: 'rows' or 'columns'...")
  }

  if (axis == 0){
    print("Chunking expression matrix by rows...")
    nelements <- nrow(expression.matrix)
  } else if (axis == 1){
    print("Chunking expression matrix by columns...")
    nelements <- ncol(expression.matrix)
  } else{
    stop("Please select which axis to chunk by: rows(0) or columns(1)...")
  }

  # Generate indexes to chunk
  whole.chunks <- nelements %/% chunks
  partial.chunks <- nelements - (whole.chunks * chunks)

  # Output for chunked data
  chunk.list <- list()

  # Generate a random list of numbers, this will make the order random
  set.seed(0)
  random.list <- sample(1:nelements, nelements, replace = F)

  for (x in 1:chunks){
    # Add on leftovers to original chunks
    chunk <- whole.chunks
    if (x == 1){
      chunk <- chunk + partial.chunks
    }

    # Start generating a random list of numbers
    # Remove the indexes from the list if they have been selected
    selected.list <- sample(random.list, chunk, replace = F)
    random.list <- random.list[! random.list %in% selected.list]

    if(axis == 0){
      chunk.list[[as.character(x)]] <- expression.matrix[selected.list, ]
    }

    if(axis == 1){
      chunk.list[[as.character(x)]] <- expression.matrix[ ,selected.list]
    }

  }

  chunk.idx <- split(sample(1:nelements), 1:chunks)

  if(axis == 0){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[x,])
  }

  if(axis == 1){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[,x])
  }

  return(chunk.list)
}

# Combine different matrix dataframes into one large matrix
#' MergeExprsMtx
#'
#' Merge a list of expression matrices in data frame format into one large data frame.
#' @param x A list of data frames containing expression matrices.
#' @export
#'
MergeExprsMtx <- function(x){
  # Character vector to add all matrix gene identifiers to
  master.gene.ids <- c()
  exprs.mtx.list <- list()

  # Loop to process expression matrices
  n <- 1
  for (exprs.mtx in x){
    # Processing of rownames (gene ids)
    exprs.mtx.gene.ids <- rownames(exprs.mtx)
    exprs.mtx.gene.ids <- make.unique(as.character(exprs.mtx.gene.ids))
    master.gene.ids <- c(master.gene.ids, exprs.mtx.gene.ids)

    # Processing of colnames (cell identifiers)
    colnames(exprs.mtx) <- paste(colnames(exprs.mtx), as.character(n), sep="-")

    # Outputting edited data frame to a list
    formatted.mtx <- cbind(data.frame(rownames=I(exprs.mtx.gene.ids)), exprs.mtx)
    rownames(formatted.mtx) <- exprs.mtx.gene.ids
    exprs.mtx.list[[n]] <- formatted.mtx
    n <- n + 1
  }

  # Create a new set of indexes to concatenate by
  unique.gene.ids <- unique(master.gene.ids)
  output.df <- data.frame(rownames=unique.gene.ids)
  row.names(output.df) <- unique.gene.ids

  for (df in exprs.mtx.list){
    output.df <- dplyr::left_join(output.df, df, by="rownames")
  }

  rownames(output.df) <- output.df[["rownames"]]
  output.df$rownames <- NULL
  output.df[is.na(output.df)] <- 0
  return(output.df)
}

#' ConvertMatrix
#'
#' Converts matrix to format of choice. This function gets called by other functions.
#'
#' @param matrix A data frame, dense matrix or sparse matrix.
#' @param format Format to change the matrix to.
#' @export
#'
ConvertMatrix <- function(matrix, format = c("data.frame", "matrix", "sparse.matrix")){
  # Make sure format is specified correctly
  if (!any(format %in% c("data.frame", "matrix", "sparse.matrix"))){
    stop("Please specify format as one of the following: data.frame, matrix or sparse.matrix")
  }

  # Dense matrix
  if (is.matrix(matrix)){
    if (format == "data.frame"){
      output <- as.data.frame(matrix)
    }
    else if (format == "sparse.matrix"){
      output <- Matrix::Matrix(matrix, sparse = TRUE)
    } else{
      output <- matrix
    }
  }

  # Data frame
  else if (is.data.frame(matrix)){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "sparse.matrix"){
      output <- Matrix::Matrix(as.matrix(matrix), sparse = TRUE)
    }
    else{
      output <- matrix
    }
  }

  # Sparse matrix
  else if (is(matrix, "sparseMatrix")){
    if (format == "matrix"){
      output <- as.matrix(matrix)
    }
    else if (format == "data.frame"){
      output <- as.data.frame(as.matrix(matrix))
    }
    else{
      output <- matrix
    }
  }

  else{
    stop("Please provide a matrix of one of the following types: data.frame, matrix or sparse matrix.")
  }

  # Whatever it is, return something
  return(output)
}

# Function - generic check if it exists
# Basic function to check if all items in one list, is present in another list
CheckData <- function(object, query) {
  matches <- !all(is.na(match(query, object)))
  return(matches)
}

# This little snippet is designed in a way in which you pair it up with a call to process the file
FileCheck <- function(filename) {
  if (!(file.exists(filename))) {
    stop(sprintf("%s is missing", filename))
  } else {
    return(FALSE)
  }
}
