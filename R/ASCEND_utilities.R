#' GetGeneCondition
#'
#' Generates a condition list of cell identifiers and if they are expressing the specified gene.
#'
#' @param object An \linkS4class{AEMSet}
#' @param gene Gene or transcript ID to label
#'
MakeGeneCondition <- function(object, gene){
  if (class(object) == "AEMSet"){
    expression.matrix <- GetExpressionMatrix(object, "data.frame")
  } else{
    stop("Please specify an AEMSet.")
  }

  if (is.character(gene) && (gene %in% rownames(expression.matrix))){
    transcript.counts <- expression.matrix[gene, ]
    transcript.counts[, which(transcript.counts > 0)] <- "On"
    transcript.counts[, which(transcript.counts == 0)] <- "Off"
    transcript.counts <- unlist(transcript.counts)
  } else{
    stop("Please specify an identifier that is in the expression matrix.")
  }

  if (!is.null(transcript.counts)){
    return(transcript.counts)
  }
}

#' PlotPDF
#'
#' Takes a list of plots generated by \pkg{ASCEND} and prints them to PDF.
#' @param plot.list A list of plots generated by \pkg{ASCEND}
#' @param filename Name of the file you would like to output to
#' @param width Width of the PDF
#' @param height Height of the PDF
#'
PlotPDF <- function(plot.list, filename = NULL, width = 11, height = 8.5){
  if (missing(filename)){
    stop("Please specify a filename.")
  }

  # Set file to print out to
  pdf(filename, width = width, height = height)
  for (plot.name in names(plot.list)){
    plot <- plot.list[[plot.name]]
    if (length(class(plot)) == 1){
      if (is.list(plot)){
        for (x in plot){
          print(x)
        }
      }
    } else{
      print(plot)
    }
  }
  dev.off()
}

# Unlog matrix - required if object was normalised with scran's deconvolution method
#' UnLog2Matrix
#'
#' Converts count values of a matrix that had undergone normalisation via scran's deconvolution method.
#' @param expression.matrix An expression.matrix
#'
UnLog2Matrix <- function(expression.matrix){
  unlog.matrix <-apply(expression.matrix, 1, function(x) 2^x)
  unlog.matrix.sub.1 <- unlog.matrix -1
  unlog.matrix.sub.1[unlog.matrix.sub.1 < 0] <- 0
  unlog.matrix.pos <- Matrix::t(unlog.matrix.sub.1)
  return(unlog.matrix.pos)
}

#' ChunkMatrix
#'
#' Chunks a matrix randomly - either along rows or columns
#' @param expression.matrix An expression matrix to chunk
#' @param axis Specify either 0 (rows) or 1 (columns)
#' @param chunks Number of chunks you would like to break the matrix into
#'
ChunkMatrix <- function(expression.matrix, axis=0, chunks = 1){
  if(missing(axis)){
    stop("Please specify axis: 'rows' or 'columns'...")
  }

  if (axis == 0){
    print("Chunking expression matrix by rows...")
    nelements <- nrow(expression.matrix)
  } else if (axis == 1){
    print("Chunking expression matrix by columns...")
    nelements <- ncol(expression.matrix)
  } else{
    stop("Please select which axis to chunk by: rows(0) or columns(1)...")
  }

  # Generate indexes to chunk
  whole.chunks <- nelements %/% chunks
  partial.chunks <- nelements - (whole.chunks * chunks)

  # Output for chunked data
  chunk.list <- list()

  # Generate a random list of numbers, this will make the order random
  set.seed(0)
  random.list <- sample(1:nelements, nelements, replace = F)

  for (x in 1:chunks){
    # Add on leftovers to original chunks
    chunk <- whole.chunks
    if (x == 1){
      chunk <- chunk + partial.chunks
    }

    # Start generating a random list of numbers
    # Remove the indexes from the list if they have been selected
    selected.list <- sample(random.list, chunk, replace = F)
    random.list <- random.list[! random.list %in% selected.list]

    if(axis == 0){
      chunk.list[[as.character(x)]] <- expression.matrix[selected.list, ]
    }

    if(axis == 1){
      chunk.list[[as.character(x)]] <- expression.matrix[ ,selected.list]
    }

  }

  chunk.idx <- split(sample(1:nelements), 1:chunks)

  if(axis == 0){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[x,])
  }

  if(axis == 1){
    chunk.list <- lapply(chunk.idx, function(x) expression.matrix[,x])
  }

  return(chunk.list)
}

# Convenience function - makes sure a dense matrix is loaded
#' LoadMatrix
#'
#' Converts a dense matrix or data frame into a sparse matrix.
#' @param x A dense matrix, data frame or AEMSet.
#'
LoadMatrix <- function(x){
  if (is.data.frame(x)){
    matrix <- as.matrix(x)
  }else if(is.matrix(x)){
    if(is(x, "sparseMatrix")){
      matrix <- as.matrix(x)
    } else{
      matrix <- x
    }
  } else if(class(x) == "AEMSet"){
    matrix <- as.matrix(GetExpressionMatrix(x, "matrix"))
  } else {
    stop("Please supply a matrix, dataframe or AEMSet object.")
  }
  return(matrix)
}

#' GetBatchMatrix
#'
#' Retrieve a portion of the matrix by batch label
#' @param object \linkS4class{AEMSet} object
#' @param batch.id Batch identifier that you would like to retrieve
#'
GetBatchMatrix <- function(object, batch.id){
  expression.matrix <- as.matrix(object@ExpressionMatrix)
  batch.list <- object@BatchInformation
  barcodes <- names(batch.list[batch.list == batch.id])
  batch.matrix <- expression.matrix[,barcodes]
  return(batch.matrix)
}

# Combine different matrix dataframes into one large matrix
#' MergeExprsMtx
#'
#' Merge a list of expression matrices in data frame format into one large data frame.
#' @param x A list of data frames containing expression matrices.
#'
MergeExprsMtx <- function(x){
  # Character vector to add all matrix gene identifiers to
  master.gene.ids <- c()
  exprs.mtx.list <- list()

  # Loop to process expression matrices
  n <- 1
  for (exprs.mtx in x){
    # Processing of rownames (gene ids)
    exprs.mtx.gene.ids <- rownames(exprs.mtx)
    exprs.mtx.gene.ids <- make.unique(as.character(exprs.mtx.gene.ids))
    master.gene.ids <- c(master.gene.ids, exprs.mtx.gene.ids)

    # Processing of colnames (cell identifiers)
    colnames(exprs.mtx) <- paste(colnames(exprs.mtx), as.character(n), sep="-")

    # Outputting edited data frame to a list
    formatted.mtx <- cbind(data.frame(rownames=I(exprs.mtx.gene.ids)), exprs.mtx)
    rownames(formatted.mtx) <- exprs.mtx.gene.ids
    exprs.mtx.list[[n]] <- formatted.mtx
    n <- n + 1
  }

  # Create a new set of indexes to concatenate by
  unique.gene.ids <- unique(master.gene.ids)
  output.df <- data.frame(rownames=unique.gene.ids)
  row.names(output.df) <- unique.gene.ids

  for (df in exprs.mtx.list){
    output.df <- dplyr::left_join(output.df, df, by="rownames")
  }

  rownames(output.df) <- output.df[["rownames"]]
  output.df$rownames <- NULL
  output.df[is.na(output.df)] <- 0
  return(output.df)
}


# Function that converts sparse matrices to a dataframe, for use in functions
#' LoadDataFrame
#'
#' Converts a sparse matrix to a data frame.
#'
LoadDataFrame <- function(sparse.matrix){
  loaded.matrix <- as.matrix(sparse.matrix)
  loaded.dataframe <- data.frame(loaded.matrix)
  original.colnames <- colnames(loaded.dataframe)
  fixed.colnames <- gsub("[.]", "-", original.colnames)
  colnames(loaded.dataframe) <- fixed.colnames
  remove(loaded.matrix)
  return(loaded.dataframe)
}

# Function to convert dataframes to a sparse matrix, for use in functions
#' LoadSparseMatrix
#'
#' Converts a dataframe to a sparse matrix, for storage in a \linkS4class{AEMSet} object.
#'
LoadSparseMatrix <- function(dataframe){
  converted.sparse.matrix <- Matrix::Matrix(as.matrix(dataframe), sparse = TRUE)
  return(converted.sparse.matrix)
}

# Function - generic check if it exists
# Basic function to check if all items in one list, is present in another list
CheckData <- function(object, query) {
  matches <- !all(is.na(match(query, object)))
  return(matches)
}

# This little snippet is designed in a way in which you pair it up with a call to process the file
FileCheck <- function(filename) {
  if (!(file.exists(filename))) {
    stop(sprintf("%s is missing", filename))
  } else {
    return(FALSE)
  }
}
