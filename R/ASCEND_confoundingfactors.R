#' RegressGene
#'
#' Called by RemoveConfoundingFactors. This step extracts residuals from the supplied gene.
#' @param gene Gene to regress residuals from.
#' @param covariate.matrix Covariate matrix generated by RemoveConfoundingFactors.
#' @param expression.matrix A transposed expression matrix generated by RemoveConfoundingFactors.
#'
RegressGene <- function(gene, covariate.matrix, expression.matrix){
  regress.mtx <- cbind(covariate.matrix, expression.matrix[ ,gene])

  # Edit string because "-" and other mathematical symbols may interfere with the formula step that is next
  colnames(regress.mtx) <- c(gsub("\\-",'_',colnames(covariate.matrix)), "GENE")
  regress.mtx <- as.data.frame(as.matrix(regress.mtx))

  # Generates a formula for calling the columns for input into the linear regression step
  fmla <- as.formula(paste("GENE ", " ~ ", paste(gsub("\\-", '_', colnames(covariate.matrix)), collapse="+"), sep=""));

  # Linear model then extracts residuals from that result
  resid.gene <- stats::lm(fmla, data = regress.mtx)$residuals
  resid.gene <- as.data.frame(resid.gene)
  names(resid.gene) <- gene

  # Populates the results into data.resid as a matrix
  return(resid.gene)
}

#' RemoveConfoundingFactors
#'
#' This function generates a scaled regression matrix based on candidate genes supplied by the user. This function is best used after normalisation.
#' @param expression.matrix Expression matrix in data frame format. You may load it from a AEMSet object with the GetExpressionMatrix function.
#' @param candidate.genes A list of genes you wish to regress from the dataset. Refer to the vignette on how to choose genes for regression.
#' @export
#'
RemoveConfoundingFactors <- function(expression.matrix, candidate.genes = list()){
  # INPUT VERIFICATION STEPS
  ## Check user has supplied a list of genes
  ## Check that the genes in the candidate list are in the rownames of the data frame
  if ( !(length(candidate.genes) > 0) ){
    stop("Please supply a list of gene candidates.")
  }

  # Work with the matrix as a data frame
  # Insert checks for matrix to dataframe
  transposed.matrix <- t(x)
  expression.matrix <- as.data.frame(transposed.matrix)

  # Different cases - make matches case-agnostic
  gene.vector <- unlist(lapply(candidate.genes, function(x) grep(x, colnames(expression.matrix), ignore.case = TRUE, value = TRUE)))

  ## Check 2 - In case there are no matches
  if (length(gene.vector) == 0){
    stop("The genes you have supplied in your candidate gene list are not present. Please revise your list.")
  }

  # Create a matrix of covariate (each cell in a row)
  covariate.mtx <-as.data.frame(expression.matrix[,gene.vector])

  # Parallel Process - Looping the regression through every gene
  # Regression can be done for all genes present in the matrix or a subset of genes
  # Can use all of the matrix or part of the matrix
  print("Regressing gene...")
  data.resid <- BiocParallel::bplapply(colnames(expression.matrix), function(x) RegressGene(x, covariate.mtx, expression.matrix), BPPARAM = MulticoreParam())

  # Rename the columns in the resulting matrix to their corresponding genes
  print("Regression complete. Filtering out results...")
  data.resid <- as.data.frame(data.resid)

  # Scale the data and filter out columns with NA values
  scaled.resid.data <- scale(data.resid, center = T, scale = T)

  # Filter out columns with NA values
  scaled.resid.data.table <- data.table::as.data.table(scaled.resid.data)
  filtered.table <- scaled.resid.data.table[,which(unlist(lapply(scaled.resid.data.table, function(x)!all(is.na(x))))),with=F]
  filtered.table <- as.data.frame(filtered.table)
  rownames(filtered.table) <- rownames(expression.matrix)
  return(filtered.table)
}
