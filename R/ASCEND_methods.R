#' GenerateControlMetrics
#'
#' Function called by \code{\link{GenerateMetrics}} to generate metrics for control-related statistics.
#'
#' @param x Name of a control listed in Controls.
#' @param expression.matrix Transcript counts stored in a sparse matrix object.
#' @param control.list A list of controls supplied by the user.
#' @param total.counts List of total counts generated by \code{\link{GenerateMetrics}}.
#'
GenerateControlMetrics <-
  function(x,
           expression.matrix = NULL,
           control.list = NULL,
           total.counts = NULL) {
    control.group <- control.list[[x]]
    control.bool <- rownames(expression.matrix) %in% control.group
    control.transcript.counts <- expression.matrix[control.bool,]
    control.transcript.total.counts <-
      Matrix::colSums(control.transcript.counts)
    control.pt.matrix <-
      (control.transcript.total.counts / total.counts) * 100
    named.list <-
      list(ControlTranscriptCounts = control.transcript.total.counts,
           PercentageTotalCounts = control.pt.matrix)
    output.list <- list()
    output.list[[x]] <- named.list
    return(output.list)
  }

#' GenerateMetrics
#'
#' This function generates the following set of values per cell:
#' \itemize{
#' \item{\strong{Total Counts}: Total number of expressed transcripts per cell}
#' \item{\strong{Total Feature Counts per Cell}: Number of non-control genes expressed per cell}
#' \item{\strong{Total Expression}: Total number of expressed transcripts in the dataset}
#' \item{\strong{Top Gene List}: Entire list of genes organised from most expressed to least expressed across the entire dataset}
#' \item{\strong{Control Transcript Counts}: Total sum of control transcript counts per cell}
#' \item{\strong{Percentage Total Counts}: Percentage of transcripts originating from control genes per cell}
#' \item{\strong{AverageCounts}: Average transcript count for a gene}
#' \item{\strong{GenesPerCell}: Number of unique transcripts expressed by a cell}
#' \item{\strong{CellsPerGene}: Number of cells expressing a gene}
#' \item{\strong{CountsPerGene}: Total number of transcripts produced by that gene expressed by all cells}
#' \item{\strong{Mean Gene Expression}: Mean expression level of a gene across the entire dataset}
#' }
#'
#' This function is called by \code{\link{NewAEMSet}} and generates metrics for the new expression matrix.
#' This function can also be called independantly, to update the metrics for a \linkS4class{AEMSet} object.
#' @include ASCEND_objects.R
#'
setGeneric(
  name = "GenerateMetrics",
  def = function(object) {
    standardGeneric("GenerateMetrics")
  }
)

setMethod("GenerateMetrics", signature("AEMSet"), function(object) {
  # Retrieve required objects from AEMSet
  expression.matrix <- object@ExpressionMatrix
  control.list <- object@Controls

  ### Calculate library size per cell
  total.counts <- Matrix::colSums(expression.matrix)

  # Prepare outputs
  control.transcript.counts.list <- list()
  percentage.lists.counts.list <- list()

  # Generate Metrics
  print("Calculating control metrics...")
  control.counts <-
    BiocParallel::bplapply(
      names(control.list),
      GenerateControlMetrics,
      expression.matrix = expression.matrix,
      control.list = control.list,
      total.counts = total.counts
    )

  # Unpackage stats
  unpacked.control.counts <-
    unlist(control.counts, recursive = FALSE)
  percentage.lists.counts.list <-
    lapply(names(unpacked.control.counts),
           function(x)
             unpacked.control.counts[[x]][["PercentageTotalCounts"]])
  names(percentage.lists.counts.list) <-
    names(unpacked.control.counts)
  control.transcript.counts.list <-
    lapply(names(unpacked.control.counts),
           function(x)
             unpacked.control.counts[[x]][["ControlTranscriptCounts"]])
  names(control.transcript.counts.list) <-
    names(unpacked.control.counts)

  # Calculate feature counts (Exclude controls)
  control.bool <-
    rownames(expression.matrix) %in% (unlist(object@Controls,
                                             use.names = FALSE))

  if (any(control.bool)) {
    endogenous.exprs.mtx <- expression.matrix[!control.bool,]
  } else {
    endogenous.exprs.mtx <- expression.matrix
    percentage.lists.counts.list <-
      lapply(percentage.lists.counts.list,
             function(x)
               ifelse(is.na(x), 0, x))
    control.transcript.counts.list <-
      lapply(control.transcript.counts.list,
             function(x)
               ifelse(is.na(x), 0, x))
  }

  total.features.counts.per.cell <-
    Matrix::colSums(endogenous.exprs.mtx !=
                      0)
  counts.per.gene <- Matrix::rowSums(expression.matrix)
  average.counts <- Matrix::rowMeans(expression.matrix)
  genes.per.cell <- Matrix::colSums(expression.matrix != 0)
  cells.per.gene <- Matrix::rowSums(expression.matrix != 0)
  mean.gene.expression <- Matrix::rowMeans(expression.matrix)

  # Calculate top gene expression
  total.expression <- sum(expression.matrix)
  sorted.counts.per.gene <- sort(counts.per.gene, decreasing = TRUE)
  top.gene.list <- names(sorted.counts.per.gene)
  top.gene.bool <- rownames(expression.matrix) %in% top.gene.list
  sorted.exprs.mtx <- expression.matrix[top.gene.bool,]
  top.genes.percentage <-
    100 * sum(sorted.counts.per.gene) / total.expression

  # Load generated values into the Metrics slot
  metrics.list <-
    list(
      TotalCounts = total.counts,
      TotalFeatureCountsPerCell = total.features.counts.per.cell,
      TotalExpression = total.expression,
      TopGeneList = top.gene.list,
      TopGenesPercentage = top.genes.percentage,
      ControlTranscriptCounts = control.transcript.counts.list,
      PercentageTotalCounts = percentage.lists.counts.list,
      AverageCounts = average.counts,
      GenesPerCell = genes.per.cell,
      CellsPerGene = cells.per.gene,
      CountsPerGene = counts.per.gene,
      MeanGeneExpression = mean.gene.expression
    )
  remove(expression.matrix)
  object@Metrics <- metrics.list
  return(object)
})

#' GetExpressionMatrix
#'
#' Returns a data frame containing the expression matrix from a \linkS4class{AEMSet} object.
#'
#' @param object A \linkS4class{AEMSet} to retrieve the expression matrix from
#' @param format Format of the returned matrix - "data.frame" or "matrix"
#' @return Returns the expression matrix in the chosen format (data.frame or matrix).
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "GetExpressionMatrix",
  def = function(object, format) {
    standardGeneric("GetExpressionMatrix")
  }
)

setMethod("GetExpressionMatrix", signature("AEMSet"), function(object, format) {
  if (missing(format)){
    stop("Please specify one of the following formats: data.frame or matrix")
  }
  if (format == "data.frame") {
    sparse.expression.matrix <- object@ExpressionMatrix
    output <- LoadDataFrame(sparse.expression.matrix)
  } else if (format == "matrix") {
    sparse.expression.matrix <- object@ExpressionMatrix
    output <- as.matrix(sparse.expression.matrix)
  } else{
    stop("Please choose one of the following: data.frame, matrix")
  }
  return(output)
})

# Define GeneAnnotation Information - in case user changes their mind.

#' GetControls
#'
#' Retrieve list of controls from \linkS4class{AEMSet}.
#'
#' @param object An \linkS4class{AEMSet} object.
#' @return This function returns a list of controls defined by the user.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "GetControls",
  def = function(object) {
    standardGeneric("GetControls")
  }
)

setMethod("GetControls", signature("AEMSet"), function(object) {
  control.list <- object@Controls
  return(control.list)
})

#' UpdateControls
#'
#' Replaces the control list in a \linkS4class{AEMSet} object with a new control list. This also recalculates the metrics associated with the \linkS4class{AEMSet} object.
#' For best results, define your controls before you attempt any filtering.
#'
#' @param object An \linkS4class{AEMSet} object.
#' @param gene.list A named list containing the gene identifiers. These identifiers must match the identifiers used in the expression matrix.
#' @return This function returns an AEMSet object with the upated controls.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "UpdateControls",
  def = function(object, gene.list) {
    standardGeneric("UpdateControls")
  }
)

setMethod("UpdateControls", signature("AEMSet"), function(object, gene.list) {
  errors <- character()
  if (length(gene.list) > 0) {
    check.controls <-
      unlist(gene.list) %in% rownames(object@ExpressionMatrix)
    if (!TRUE %in% check.controls) {
      msg <-
        "Please make sure the gene identifiers you have listed in your control list matches those used in the expression matrix."
      errors <- c(errors, msg)
    }
  } else {
    msg <- "Please make sure that you have defined a control."
    errors <- c(errors, msg)
  }

  if (length(errors) > 0) {
    errors
  } else {
    object@Controls <- gene.list
    updated.object <- GenerateMetrics(object)
    return(updated.object)
  }
})

#' GetBatchInformation
#'
#' Retrieve batch information from an \linkS4class{AEMSet}.
#' @return A list of cell identifiers and their associated batch identifier.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "GetBatchInfo",
  def = function(object) {
    standardGeneric("GetBatchInfo")
  }
)

setMethod("GetBatchInfo", signature("AEMSet"), function(object) {
  return(object@BatchInformation)
})

#' UpdateBatchInfo
#'
#' Can be called by the user or by a filtering function. Updates Batch Information in a \linkS4class{AEMSet} object, removing cells that have been filtered out.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "UpdateBatchInfo",
  def = function(object) {
    standardGeneric("UpdateBatchInfo")
  }
)

setMethod("UpdateBatchInfo", signature("AEMSet"), function(object) {
  # Get present list of barcodes
  present.barcodes <- colnames(object@ExpressionMatrix)

  # Get present barcode list
  current.barcode.list <- object@BatchInformation
  updated.barcode.list <-
    current.barcode.list[names(current.barcode.list) %in%
                           present.barcodes]

  # Update the object
  object@BatchInformation <- updated.barcode.list
  return(object)
})

#' GetGeneAnnotation
#'
#' Retrieve gene annotation information from an \linkS4class{AEMSet} object.
#' @param object A \linkS4class{AEMSet} object.
#' @return This function returns a data frame.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "GetGeneAnnotation",
  def = function(object) {
    standardGeneric("GetGeneAnnotation")
  }
)

setMethod("GetGeneAnnotation", signature("AEMSet"), function(object) {
  gene.annotation <- object@GeneAnnotation
  return(gene.annotation)
})

#' ConvertGeneAnnotation
#'
#' Convert gene identifiers used in this \linkS4class{AEMSet} to identifiers used in another column of a dataframe stored in the GeneAnnotation slot.
#'
#' @param object A \linkS4class{AEMSet} object.
#' @param old.annotation Name of the column containing the current gene annotations.
#' @param new.annotation Name of the column you would like to convert the gene annotations to.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "ConvertGeneAnnotation",
  def = function(object, old.annotation,
                 new.annotation) {
    standardGeneric("ConvertGeneAnnotation")
  }
)

setMethod("ConvertGeneAnnotation", signature("AEMSet"), function(object) {
  # Get currently-used gene identifiers Load Gene Annotation
  gene.annotation <- object@GeneAnnotation

  ## From expression matrix
  present.rownames <- rownames(object@ExpressionMatrix)

  ## From control lists
  control.list <- object@Controls

  # Retrieve new values
  new.identifiers <-
    gene.annotation[gene.annotation[old.annotation] == present.rownames,][, new.annotation]

  ## Rename expression matrix
  rownames(object@ExpressionMatrix) <- new.identifiers

  # Convert control list
  updated.control.list <-
    gene.annotation[, new.annotation][which(gene.annotation[, old.annotation] %in% control.list$Mt)]
  object@Controls <- updated.control.list

  return(object)
})

#' ReplaceExpressionMatrix
#'
#' Replace the expression matrix in a \linkS4class{AEMSet} with a new expression matrix and re-calculate its metrics.
#'
#' @param x Expression matrix in matrix or data.frame.
#' @param object The \linkS4class{AEMSet} you would like to update.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "ReplaceExpressionMatrix",
  def = function(x, object) {
    standardGeneric("ReplaceExpressionMatrix")
  }
)

setMethod("ReplaceExpressionMatrix", signature("matrix", "AEMSet"), function(x, object) {
  object@ExpressionMatrix <- LoadSparseMatrix(x)
  updated.sea.set <- GenerateMetrics(object)
  return(updated.sea.set)
})

#' GetClusters
#'
#' @param object An \linkS4class{AEMSet} that has undergone clustering.
#' @return A list of cell identifiers and their assigned cluster.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "GetClusters",
  def = function(object) {
    standardGeneric("GetClusters")
  }
)

setMethod("GetClusters", signature("AEMSet"), function(object) {
  if (length(object@Clusters) == 0) {
    stop("Please run FindOptimalClusters before using this function.")
  }
  return(object@Clusters$Clusters)
})

#' SubsetBatch
#'
#' Subset a specific batch from a \linkS4class{AEMSet} object.
#'
#' @param object A \linkS4class{AEMSet} object
#' @param x Name or number of the batch you would like to subset.
#' @return An \linkS4class{AEMSet} containing only this batch.
#' @include ASCEND_objects.R
#' @export
setGeneric(
  name = "SubsetBatch",
  def = function(object, x) {
    standardGeneric("SubsetBatch")
  }
)

setMethod("SubsetBatch", signature("AEMSet", "numeric"), function(object, x) {
  # Stop the function if batch id is not present in the dataset.
  if (!any(object@BatchInformation == as.character(x))) {
    stop("Please ensure the batch ID you have selected is present in your dataset.")
  }

  # Create a new object to output, ensures original object does not get
  # overwritten.
  subset.obj <- object

  # Retrieve cells that belong to this batch from the AEMSet obejct
  batch.list <-
    object@BatchInformation[which(object@BatchInformation == as.character(x))]
  barcode.list <- names(batch.list)

  # Other information will be extracted if they exist
  if (!is.null(object@PCA$PCA)) {
    subset.obj@PCA$PCA <- object@PCA$PCA[barcode.list,]
  }

  if (!is.null(object@Clusters$DistanceMatrix)) {
    distance.matrix <-
      as.matrix(object@Clusters$DistanceMatrix)[barcode.list,
                                                barcode.list]
    subset.obj@Clusters$DistanceMatrix <- as.dist(distance.matrix)
  }

  if (!is.null(object@Clusters$PutativeClusters)) {
    subset.obj@Clusters$PutativeClusters <-
      object@Clusters$PutativeClusters[barcode.list]
  }

  if (!is.null(object@Clusters$Clusters)) {
    subset.obj@Clusters$Clusters <-
      object@Clusters$Clusters[barcode.list]
    subset.obj@Clusters$NumberOfClusters <-
      length(unique(subset.obj@Clusters$Clusters))
  }

  subset.obj@ExpressionMatrix <-
    object@ExpressionMatrix[, barcode.list]
  subset.obj@BatchInformation <- batch.list
  subset.obj <- GenerateMetrics(subset.obj)
  subset.obj@Log <- c(subset.obj@Log, list(SubsetByCluster = TRUE))
  return(subset.obj)
})

#' SubsetCluster
#'
#' Subset a \linkS4class{AEMSet} object by cluster. Please make sure you have clustered with \code{\link{FindOptimalClusters}} before using this function.
#'
#' @param object A \linkS4class{AEMSet} object
#' @param x Number of the cluster you would like to subset.
#' @return Returns an \linkS4class{AEMSet} containing only this cluster.
#' @include ASCEND_objects.R
#' @export
#'
setGeneric(
  name = "SubsetCluster",
  def = function(object, x) {
    standardGeneric("SubsetCluster")
  }
)

setMethod("SubsetCluster", signature("AEMSet", "numeric"), function(object, x) {
  # Stop the function if cluster id is not present in the dataset.
  if (!any(object@Clusters$Clusters == as.character(x))) {
    stop("Please ensure the cluster ID you have selected is present in your dataset.")
  }

  # Create a new object to output, ensures original object does not get
  # overwritten.
  subset.obj <- object

  # Retrieve cells that belong to this batch from the AEMSet obejct
  cluster.list <-
    object@Clusters$Clusters[which(object@Clusters$Clusters ==
                                     as.character(x))]
  barcode.list <- names(cluster.list)

  # Other information will be extracted if they exist
  subset.obj@PCA$PCA <- object@PCA$PCA[barcode.list,]
  distance.matrix <-
    as.matrix(object@Clusters$DistanceMatrix)[barcode.list,
                                              barcode.list]
  subset.obj@Clusters$DistanceMatrix <- as.dist(distance.matrix)
  subset.obj@Clusters$PutativeClusters <-
    object@Clusters$PutativeClusters[barcode.list]
  subset.obj@Clusters$Clusters <- cluster.list
  subset.obj@Clusters$NumberOfClusters <- 1

  subset.obj@ExpressionMatrix <-
    object@ExpressionMatrix[, barcode.list]
  subset.obj <- GenerateMetrics(subset.obj)
  subset.obj@Log <- c(subset.obj@Log, list(SubsetByCluster = TRUE))
  return(subset.obj)
})

#' DisplayLog
#'
#' Print out the log of an \linkS4class{AEMSet}.
#' @include ASCEND_objects.R
#'
setGeneric(
  name = "DisplayLog",
  def = function(object) {
    standardGeneric("DisplayLog")
  }
)

setMethod("DisplayLog", signature("AEMSet"), function(object){
  log <- object@Log
  print(log)
})
