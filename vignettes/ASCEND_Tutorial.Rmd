---
title: An introduction to ASCEND - Analysis of Single Cell Expression, Normalisation
  and Differential expression
author: "Anne Senabouth"
date: '`r Sys.Date()`'
output:
  html_document: rmarkdown::html_vignette
  pdf_document: default
vignette: |
  %\VignetteIndexEntry{ASCEND Tutorial} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

The `ASCEND` package provides a series of tools for the processing and analysis of single cell RNA-seq (scRNA-seq) in R. These tools perform tasks such as filtering, normalisation, clustering and differential expression.

## Before you begin
### System Requirements
Datasets produced by scRNASeq experiments are very large, ranging from a few hundred to a million cells. The number of cells affect the amount of computational resources required to process the dataset – therefore, you need to determine if you have enough computational power and time to complete the analysis. ASCEND can comfortably analyse datasets of up to 10,000 cells on a single machine with 8GB of RAM and a quad-core CPU. Larger datasets should be run on a High Performance Cluster (HPC).

### Configuring BiocParallel
This package makes extensive use of [BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html), enabling ASCEND to make the most of your computer's hardware. As each system is different, BiocParallel needs to be configured by the user. Here are some example configurations.

#### Unix/Linux/MacOS (Single Machine)
```{r SetupNix, eval = TRUE}
library(BiocParallel)
ncores <- parallel::detectCores() - 1
register(MulticoreParam(workers = ncores, progressbar=TRUE), default = TRUE)

```

#### Windows (Single Machine - Quad-core system)
```{r SetupWin, eval = FALSE}
library(BiocParallel)
workers <- 3 # Number of cores on your machine - 1
register(SnowParam(workers = workers, type = "SOCK", progressbar = TRUE), default = TRUE)
```

#### Cluster (PBSPro)
```{r SetupCluster, eval = FALSE}
library(BiocParallel)
library(Rmpi)
# Rmpi code here
```

#### Loading ASCEND
Please use `devtools` to load the development version of `ASCEND`.

```{r LoadASCEND}
devtools::load_all("/Users/a.senabouth/Code Repositories/ASCEND")
```

You can also use devtools' install_github function to install the package, and then load it as normal.

```{r LoadASCENDGit, eval = FALSE}
devtools::install_github("IMB-Computational-Genomics-Lab/ASCEND")
library(ASCEND)
```

## Loading Data for use in ASCEND
### Preparing data manually
This vignette uses the public dataset ["Aggregate of t_3k and t_4k"](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.0.1/t_3k_4k_aggregate) by 10x Genomics. The dataset consists of 8093 pan T cells that were isolated from a healthy donor, and are divided into two batches. 

You can download the dataset from [here](http://cf.10xgenomics.com/samples/cell-exp/1.3.0/t_3k_4k_aggregate/t_3k_4k_aggregate_filtered_gene_bc_matrices_mex.tar.gz).


This download - **Gene / cell matrix (filtered)**, contains the following files:

- barcodes.tsv
- genes.tsv
- matrix.mtx

These files contain all the information we need to create an `AEMSet` - the main data object of the ASCEND package. 

#### Expression matrix
The main source of input is an expression matrix, or a gene/cell matrix where each row represents a transcript and each column represents a cell. Cell Ranger - the processing pipeline for the Chromium platform, has stored the expression matrix in a Market Exchange Format (MEX) file called `matrix.mtx`. We need to use the `readMM` function from the `Matrix` package to load the data into R.

```{r ReadExpressionMatrix}
library(Matrix)
matrix.mtx <- "t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/matrix.mtx"
expression.matrix <- readMM(matrix.mtx)
expression.matrix <- as.data.frame(as.matrix(expression.matrix))
expression.matrix[1:5,1:5]
```

`readMM` reads the data in as a sparse matrix, using less memory than data frames and matrices. The expression matrix can be kept in this format, but as we want to view the contents of the matrix for this tutorial – we have converted it into a data frame.  This data frame lacks row and column labels as Cell Ranger has stored them in the two other files - `barcodes.tsv` and `genes.tsv`.

#### Cell Identifiers and Batch Information
`barcodes.tsv` is a CSV file containing cell identifier and batch information. Chromium uses actual cell barcodes as cell identifiers and has attached a number to each barcode. This number represents the batch the cell originated from.

```{r ReadBarcodes}
barcodes.tsv <- "t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/barcodes.tsv"
barcodes <- read.csv(barcodes.tsv, sep="\t", header = FALSE)
barcodes[1:5,]
```

Extract the batch numbers from the cell identifiers by splitting each string at the '-' symbol and retrieve the second part of the string. Next, link each cell barcode to its associated batch by transforming the vector into a named list.

```{r ProcessBatchID}
batch.information <- lapply(strsplit(as.character(barcodes$V1), "-"), `[`, 2)
names(batch.information) <- barcodes$V1
batch.information[1:5]
```

Finally, add the cell identifiers to the expression matrix as column names.

```{r NameColumns}
colnames(expression.matrix) <- barcodes$V1
expression.matrix[1:5, 1:5]
```

#### Gene Annotation
`genes.tsv` contains the names of transcripts identified by Cell Ranger. This csv file contains ENSEMBL transcript IDs in one column and their corresponding gene name in the other column. Either of these identifiers can be used as row names in the expression matrix. 

```{r ReadGenes}
genes.tsv <- "t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/genes.tsv"
gene.annotations <- read.csv(genes.tsv, sep="\t", header = FALSE)
colnames(gene.annotations) <- c("ensembl_id", "gene_name")
gene.annotations[1:5,]
```

For this tutorial, we will use gene names. As genes can be associated with more than one transcript, we need to make the names unique with `make.unique` before adding them to the expression matrix.

```{r SetRownames}
gene.names <- make.unique(as.vector(gene.annotations$gene_name))
rownames(expression.matrix) <- gene.names
expression.matrix[1:5, 1:5]
```

Now that the gene names have been modified, the gene_names column in the `gene.annotations` data frame needs to be updated. This will link the information in this data frame with the rows of the expression matrix.

```{r ReplaceGeneNames}
gene.annotations$gene_name <- gene.names
gene.annotations[1:15,]
```

#### Defining Controls
Finally, we need to identify controls for this experiment. Ribosomal and mitochondrial genes are typically used as controls for single-cell experiments, so will use these genes for the tutorial. Spike-ins should be used as controls if they are included in the experiment.

```{r DefineControls}
# Mitochondrial gene list from
mito.genes <- c("MT-ND1", "MT-ND2", "MT-ND3", "MT-ND4L", "MT-ND4", "MT-ND5", "MT-ND6", "MT-CYB", "MT-CO1", "MT-CO2", "MT-CO3", "MT-ATP6", "MT-ATP8", "MT-CYB")

# Ribosomal gene list from http://ribosome.med.miyazaki-u.ac.jp/
ribo.genes <- c("RPSA", "RPS2", "RPS3", "RPS3A", "RPS4X", "RPS5", "RPS6", "RPS7", "RPS8", "RPS9", "RPS10", "RPS11", "RPS12", "RPS13", "RPS14", "RPS15", "RPS15A", "RPS16", "RPS17", "RPS18", "RPS19", "RPS20", "RPS21", "RPS23", "RPS24", "RPS25", "RPS26", "RPS27", "RPS27A", "RPS28", "RPS29", "RPL3", "RPL4", "RPL5", "RPL6", "RPL7", "RPL7A", "RPL8", "RPL9", "RPL10", "RPL10A", "RPL11", "RPL12", "RPL13", "RPL13A", "RPL14", "RPL15", "RPL17", "RPL18", "RPL18A", "RPL19", "RPL21", "RPL22", "RPL23", "RPL23A", "RPL24", "RPL26", "RPL27", "RPL27A", "RPL28", "RPL29", "RPL30", "RPL31", "RPL32", "RPL34", "RPL35", "RPL35A", "RPL36", "RPL36A", "RPL37", "RPL37A", "RPL38", "RPL39", "RPL41", "RPLP0", "RPLP1", "RPLP2")

controls <- list(Mt = mito.genes, Rb = ribo.genes)

```

#### Building an AEMSet
We can now load all of this information into an `AEMSet`, using the `NewAEMSet` function.

```{r BuildAEMSet}
aem.set <- NewAEMSet(ExpressionMatrix = expression.matrix, GeneAnnotation = gene.annotations, BatchInformation = batch.information, Controls = controls)
aem.set
```

### Load data from Cell Ranger into ASCEND automatically
If you are using Chromium data, you can also load the data into R with this function.

```{r AutoLoading, eval = FALSE}
aem.set <- CellRangerToASCEND("t_3k_and_t_4k/", "GRCh38")
```

This function loads the data into an AEMSet, with the assumption that mitochondrial and ribosomal genes are controls for this experiment.

## Single-cell post-processing and normalisation workflow
The filtering workflow is based off [A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor][1] by Lun, McCarthy & Marioni 2016.

### Preliminary QC
We can assess the quality of the data through a series of plots generated by `PlotGeneralQC`. These plots will be used to guide the filtering process.

#### Printing plots to PDF
The resulting plots are stored in a named list. You can use the `PlotPDF` function to output the plots in this list to a PDF file.

```{r, fig.show = "hide"}
raw.qc.plots <- PlotGeneralQC(aem.set)
PlotPDF(raw.qc.plots, "RawQC.pdf")
```


### Cell filtering 
#### Filter cells by library size and gene expression
First, we will filter cells based on outliers in term of library size, number of non-control genes expressed and control genes expressed. 

We can use the following plots to examine the distributions of these values.
```{r, fig.align="center", fig.width = 5, fig.show = "hold"}
print(raw.qc.plots$LibSize)
print(raw.qc.plots$FeatureCountsPerCell)
print(raw.qc.plots$ControlPercentageTotalCounts$Mt)
print(raw.qc.plots$ControlPercentageTotalCounts$Rb)
```

The `FilterByOutliers` function will remove outliers based on these criteria. The threshold arguments refer to the median absolute deviations (MADs) below the median. These are set to 3 by default, but you can adjust them if required

```{r FilterByOutliers}
aem.set <- FilterByOutliers(aem.set, CellThreshold = 3, ControlThreshold = 3)
```

#### Filter cells by control gene expression
We removed a significant number of cells in the previous step that were expressing too many, or too few control genes. As ribosomal and mitochondrial genes are indicative of a stressed or dying cell, we need to perform some additional filtering and remove cells where they contribute to the bulk of the cell's expression.

The beehive plots below show the percentage of control genes in the transcriptomes of each cell, per sample.

```{r ControlPercentagePlots, fig.width=5, fig.height=4, fig.align="center", fig.show = "hold"}
print(raw.qc.plots$ControlPercentageSampleCounts$Mt)
print(raw.qc.plots$ControlPercentageSampleCounts$Rb)
```

Review the control list by using `GetControls`. As you can see, we have stored the mitochondrial genes under "Mt" and ribosomal genes under "Rb."

```{r RetrieveControls}
print(GetControls(aem.set))
```

Use `FilterByCustomControl` to remove cells that are mostly expressing control genes. This function takes two arguments - the name of the list of control genes and the minimum percentage expression to filter by.

```{r FilterByControl}
# Filter by mitochondrial genes
aem.set <- FilterByCustomControl("Mt", 20, aem.set)
# Filter by ribosomal genes
aem.set <- FilterByCustomControl("Rb", 50, aem.set)
```

Some analyses will require the removal of these controls. This should not be done at this stage; it is best done after normalisation.

#### Filtering by expression
The final step of filtering is to remove low-abundance genes. The average expression of genes can be reviewed on the average transcript count plots.

```{r AverageGeneCountPlots, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$AverageGeneCount)
```

Due to the nature of single-cell RNASeq, many genes will have zero or near-zero expression. Have a closer look at the distribution with the Log2 and Log10 average transcript count plots. 

```{r AverageGeneCountLogPlots, fig.align="center", fig.show = "hold", fig.width = 5}
print(raw.qc.plots$Log2AverageGeneCount)
print(raw.qc.plots$Log10AverageGeneCount)
```

Use `FilterByExpressedGenesPerCell` to remove genes that have zero or near-zero expression in at least a certain percentage of the cell population. We will use the value of 1% for this tutorial.

```{r FilterByExpressedGenesPerCell}
aem.set <- FilterByExpressedGenesPerCell(aem.set, 0.01)
```

#### Filtering Review
Review the impact of filtering on the dataset by running `PlotGeneralQC` again. `ASCEND` has also kept track of the filtering process and has recorded which cells and genes were filtered from the dataset.

```{r CheckFiltering, echo = FALSE, fig.show = "hold", fig.width = 5}
filtered.qc.plots <- PlotGeneralQC(aem.set)
print(filtered.qc.plots$LibSize)
print(filtered.qc.plots$FeatureCountsPerCell)
```

You can view the log with `DisplayLog`.
```{r CheckLogFiltering}
DisplayLog(aem.set)
```

### Normalisation
Normalisation needs to be done at two levels - between batches and between cells.

The ASCEND package contains the following normalisation functions:

* NormaliseBatches: Normalise library sizes between batches.
* NormaliseByRLE: Normalise library sizes between cells by Relative Log Expression (RLE).
* scranNormalise: Normalise library sizes between cells using *scran*'s deconvolution method.

How you use these functions depends on the dataset.

#### NormaliseBatches
Normalisation between batches needs to be done prior to filtering.

For this tutorial - we do not need to use the `NormaliseBatches` as this dataset was prepared with Cell Ranger's *aggr* pipeline. This pipeline uses a subsampling process to normalise between batches [(Zheng et al. 2017)][2].

We do need to normalise between cells so we can use one of the following functions: `NormaliseByRLE` or `scranNormalise`.

#### NormaliseByRLE
In this method, each cell is considered as one library and assumes that most genes are not differentially expressed. It uses gene expression values higher than 0 to calculate the geometric means of a gene. The geometric mean is the mean of the expression of the gene across all cells (for cells where the gene is detected). Each gene has one geometric mean value for all cell. For each cell, the gene expression values are divided by the geometric means to get one normalisation factor for a gene in that cell. The median of all the normalisation factors for all genes in that cell is the normalisation factor for the cell. Post RLE normalisation, a gene with 0 expression still has 0 expression. A gene with expression higher than 0 will have an expression value equal the raw expression divided by the calculated normalization factor for the cell. As spike-ins affect library size, they need to be removed prior to normalisation.

This method is relatively quick and can be run on a desktop.

```{r NormaliseByRLE}
norm.set <- NormaliseByRLE(aem.set)
```

#### scranNormalise
This function is a wrapper for the deconvolution method by [Lun et al. 2015][3] that uses the [scran][1] and [scater][3] packages. This method takes into account the high proportion of zero counts in single-cell data and tackles the zero-inflation problem by applying a pooling strategy to calculate size-factors of each pool. The pooled size factors are then deconvoluted to infer the size factor for each cell, which are used scale the counts within that cell. The [scran vignette][4] explains the whole process in greater detail.

If the dataset contains less than 10,000 cells, `scranNormalise` will run `scran`'s `computeSumFactors` function with preset sizes of 40, 60, 80 and 100. For larger datasets, `scranNormalise` will run `quickCluster` before `computeSumFactors`.

This method is computationally intensive; we do not recommend running datasets larger than 5000 cells on a desktop machine. Datasets larger than 10,000 cells should be run on a HPC.

To ensure compatibility with `scran` and `scater`, the `AEMSet` needs to have mitochondrial and ribosomal genes as controls. The control list also needs to be formatted as follows:

```{r GetControlsScran}
print(GetControls(aem.set))
```

Run `scranNormalise` as follows:

```{r scranNormalise, eval = FALSE}
norm.set <- scranNormalise(aem.set)
```

#### Reviewing the normalisation process
`PlotNormQC` will generate a series of plots for the review of the normalisation process. This function can only be used if you have retained the un-normalised `AEMSet`.

```{r PlotNormalisationQC}
norm.qc <- PlotNormalisationQC(original = aem.set, normalised = norm.set, gene.list = c("GAPDH", "ACTB"))
```

The first set of graphs are library size histograms. The `NormaliseByRLE` method does not affect library size as drastically as the `scranNormalise` method. Instead, the changes are more apparent on a gene level.

```{r NormLibsizePlot, fig.show = "hold", fig.align="center"}
print(norm.qc$Libsize$Original)
print(norm.qc$Libsize$Normalised)
```

The gene scatter plots show how expression has changed on a gene level. As GAPDH is highly expressed in this dataset, the effect of normalisation is not as apparent as it is for ACTB.
```{r NormScatter, fig.show="hold", fig.align="center", fig.width = 5}
print(norm.qc$GeneScatterPlots$GAPDH$Original)
print(norm.qc$GeneScatterPlots$GAPDH$Normalised)
print(norm.qc$GeneScatterPlots$ACTB$Original)
print(norm.qc$GeneScatterPlots$ACTB$Normalised)
```

The changes to overall gene expression can also be reviewed on gene expression boxplots.

```{r NormGenes, fig.width = 5, fig.show="hold", fig.align = "center"}
print(norm.qc$GeneExpressionBoxplot$Original)
print(norm.qc$GeneExpressionBoxplot$Normalised)
```

### Control Removal
The plot generated by `PlotTopExpression` show ribosomal genes dominate the list of the most-expressed genes.

```{r ControlRemovalPlot1, fig.width = 5, fig.height = 4, fig.align="center"}
top.20.plot <- PlotTopGeneExpression(aem.set, n = 20, controls = TRUE)
print(top.20.plot)
```

As we are interested in the expression of non-control genes, we will need to remove the controls from the dataset. This can be done with the `ExcludeControl` function.

```{r ExcludeControls}
aem.set <- ExcludeControl(aem.set, "Mt")
aem.set <- ExcludeControl(aem.set, "Rb")
```

Now that the control genes have been removed, the plot reveals many other genes of interest.

```{r ControlRemovalPlot2, fig.width = 5, fig.height = 4, fig.align="center"}
top.20.plot <- PlotTopGeneExpression(aem.set, n = 20, controls = TRUE)
print(top.20.plot)
```

### Dimension Reduction
We have filtered our dataset down to 6100 cells and 33604 genes. We can reduce this dataset further by using *Principal Component Analysis (PCA)* to identify genes that are major contributors to variation.

```{r DimReduction1}
aem.set <- RunPCA(aem.set)
```

PlotPCAVariance` generates what is known as a *scree plot*, which depicts what percentage each PC contributes to the total variance of the data. This will help determine how many PCs the dataset should be reduced to.

```{r PlotPCAVariance, fig.show="hold", fig.align="center", fig.width = 5}
pca.variance <- PlotPCAVariance(aem.set, 50)
print(pca.variance)
```

The scree plot shows most of the variance is due to the top 20 PCs. Reduce the dataset to 20 PCs with the `ReduceDimensions` function.

```{r ReduceDimensions}
aem.set <- ReduceDimensions(aem.set, 20)
```

### Clustering
Clustering can be done on the original expression matrix or the PCA-transformed matrix, which is the preferred input. Use `FindOptimalClusters` to identify clusters.

```{r FindOptimalClusters}
aem.set <- FindOptimalClusters(aem.set)
```

The `FindOptimalClusters` function generates a distance matrix based on the input and from this, builds a dendrogram. This dendrogram is then cut with the `DynamicTreeCut` algorithm to select clusters from the dendrogram based on the shape and size of the branches. This is repeated again, but this time with the tree-height parameter set to 40 values ranging from 0.025 (the bottom of the tree) to 1 (the top of the tree). 

The `PlotStabilityDendro` generates a plot that represents this part of the process. In addition to the dendrogram, it generates the distribution of clusters across the 40 cut heights.

```{r PlotStabilityDendro, fig.width=4, fig.height=5, fig.show="hold", fig.align="center"}
PlotStabilityDendro(aem.set)
```

The clustering results are then compared quantitatively using rand indices, which calculates every pair of cells being in the same cluster or not. It is used as an indicator of the stability of a clustering result. If a rand index is stable across multiple tree-height values, this indicates the tree-height produces the most stable clustering result.  

This information is shown on a plot generated by the `PlotStability` function.

```{r PlotStability, fig.width=5, fig.height=4, fig.show="hold", fig.align="center"}
PlotStability(aem.set)
```

The rand index is stable in 50% of tree-cut heights that correspond to the lowest number of clusters. Therefore, the optimal number of clusters is 2.

The `PlotDendrogram` function generates a dendrogram that depicts each cluster and its members.

```{r PlotDendrogram, fig.width=5, fig.height=4, fig.show="hold", fig.align="center"}
PlotDendrogram(aem.set)
```

### Differential Expression
This package uses `DESeq` to perform differential expression, and can be done with or without clustering. Each cell needs to be assigned one of two conditions; for this tutorial, we will use batch information and clustering information. This step is computationally intensive for larger datasets.

#### Differential expression by condition
The `RunDiffExpression` function requires an `AEMSet`, two conditions and a list of cells and their associated condition.

We already have this condition list – batch information, which we can retrieve from the `AEMSet`. The conditions are therefore “1” and “2”.

```{r RunDiffExpression}
batch.info <- GetBatchInfo(aem.set)
batch.de.result <- RunDiffExpression(aem.set, condition.a = "1", condition.b = "2", condition.list = batch.info)
```

The results are sorted in ascending order, based on the p-value. The fold change values have been adjusted; they represent absolute fold change.

```{r DEResult1}
batch.de.result[1:10,]
```


#### Differential expression by cluster comparison
`RunClusterDiffExpression` compares each cluster against other clusters. This function returns a list of differential expression results.

```{r RunClusterDiffExpression}
cluster.de.result <- RunClusterDiffExpression(aem.set)
```

As there are only two clusters, only one comparison was made.

```{r DEResult2}
cluster.de.result$`1vs2`[1:10,]
```

## Visualising data with ASCEND
`ASCEND` provides functions for generating PCA, TSNE and MDS plots that can be supplied with a condition list. The conditions can be of clustering results, batch information or the expression of specific genes.

#### Generating a condition list
The function `MakeGeneCondition` generates a condition list, labelling if a cell is expressing the selected gene, or not. This can be used to highlight cells that are expressing genes on plots generated by the `ASCEND` package.

We will label cells that are expressing the IGLC2 transcript.

```{r ConditionList}
condition.list <- MakeGeneCondition(aem.set, "IGLC2")
```

#### PlotPCA
```{r PlotPCA, fig.show="hold", fig.align="center", fig.width = 5}
pca.plot <- PlotPCA(aem.set, condition.list = condition.list)
print(pca.plot)
```

#### PlotTSNE
```{r PlotTSNE, fig.show="hold", fig.align="center", fig.width = 5}
tsne.plot <- PlotTSNE(aem.set, PCA = TRUE, condition.list = condition.list)
print(tsne.plot)
```

#### PlotMDS
```{r PlotMDS, fig.show="hold", fig.align="center", fig.width = 5}
mds.plot <- PlotMDS(aem.set, PCA = FALSE, condition.list = condition.list)
print(mds.plot)
```

## References
[1]: https://f1000research.com/articles/5-2122/v2
Lun ATL, McCarthy DJ and Marioni JC. A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor [version 2; referees: 3 approved, 2 approved with reservations]. F1000Research 2016, 5:2122 (doi: 10.12688/f1000research.9501.2)

[2]: https://www.nature.com/articles/ncomms14049
Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 doi: 10.1038/ncomms14049 (2017).

[3]: https://bioconductor.org/packages/release/bioc/html/scater.html
McCarthy DJ, Campbell KR, Lun ATL and Wills QF (2017). “Scater: pre-processing, quality control, normalisation and visualisation of single-cell RNA-seq data in R.” Bioinformatics, 14 Jan. doi: 10.1093/bioinformatics/btw777, http://dx.doi.org/10.1093/bioinformatics/btw777.

[4]: https://bioconductor.org/packages/release/bioc/vignettes/scran/inst/doc/scran.html
Lun ATL, McCarthy DJ and Marioni JC (2016). “A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.” F1000Res., 5, pp. 2122.
