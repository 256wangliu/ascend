---
title: "An introduction to ASCEND - Analysis of Single Cell Expression, Normalisation and Differential expression"
author: "Anne Senabouth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ASCEND Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `ASCEND` package provides a series of tools for the processing and analysis of single cell RNA-seq (scRNA-seq) in R. These tools performs tasks such as filtering, normalisation, clustering and differential expression.

## Before you begin
### System Requirements
Datasets produced by scRNASeq experiments are very large, ranging from a few hundred to a million cells. The number of cells affect how much computational resources are required to process the dataset. Therefore, you need to determine if you have enough computational power and time to complete the analysis. ASCEND can comfortably analyse datasets of up to 10000 cells on a single machine with 8GB of RAM and a quad-core CPU. Datasets larger than this should be run on a high performance cluster (HPC).

### Configuring BiocParallel
This package makes extensive use of [BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html), enabling ASCEND to make the most of your computer's hardware. As each system is different, BiocParallel needs to be configured by the user. Here are some example configurations.

#### Unix/Linux/MacOS (Single Machine)
```{r SetupNix, eval = TRUE}
library(BiocParallel)
ncores <- parallel::detectCores() - 1
register(MulticoreParam(workers = ncores, progressbar=TRUE), default = TRUE)
```

#### Windows (Single Machine - Quad-core system)
```{r SetupWin, eval = FALSE}
library(BiocParallel)
workers <- 3 # Number of cores on your machine - 1
register(SnowParam(workers = workers, type = "SOCK", progressbar = TRUE), default = TRUE)
```

#### Cluster (PBSPro)
```{r SetupCluster, eval = FALSE}
library(BiocParallel)
library(Rmpi)
# Rmpi code here
```

#### Loading ASCEND
As this package is still under development, please use devtools to load the package.

```{r LoadASCEND}
devtools::load_all("/Users/a.senabouth/Code Repositories/ASCEND")
```

You can also use devtools' install_github function to install the package. You can then load the package as normal.

```{r LoadASCENDGit, eval = FALSE}
devtools::install_github("MB-Computational-Genomics-Lab/ASCEND")
```

## Loading Data for use in ASCEND
### Preparing data manually
The vignette uses the public dataset ["Aggregate of t_3k and t_4k"](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.0.1/t_3k_4k_aggregate) by 10x Genomics. This dataset consists of 8093 pan T cells that are divided into two batches. The cells were isolated from a healthy donor.

You can download the dataset from [here](http://cf.10xgenomics.com/samples/cell-exp/1.3.0/t_3k_4k_aggregate/t_3k_4k_aggregate_filtered_gene_bc_matrices_mex.tar.gz).


The **Gene / cell matrix (filtered)** download contains the following files:

- barcodes.tsv
- genes.tsv
- matrix.mtx

These files contain all the information we need to create an `AEMSet` - the main data object of the ASCEND package. 

#### Expression matrix
The main source of input is an expression matrix, or a gene/cell matrix containing transcript counts. Each row represents a gene and each column represents a cell. Cell Ranger - the processing pipeline for the Chromium platform, has stored the expression matrix in a Market Exchange Format (MEX) file called `matrix.mtx`. We need to use the `readMM` function from the `Matrix` package to load the data into R.

```{r ReadExpressionMatrix}
library(Matrix)
matrix.mtx <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/matrix.mtx"
expression.matrix <- readMM(matrix.mtx)
expression.matrix <- as.data.frame(as.matrix(expression.matrix))
expression.matrix[1:5,1:5]
```

`readMM` reads the data in as a sparse matrix. This format uses less memory than data frames and matrices. We have converted the expression matrix into a data frame so we can view its contents. As you can see, there column and row labels aren't very helpful. This is because Cell Ranger has stored them in the two other files - `barcodes.tsv` and `genes.tsv`.

#### Cell Identifiers and Batch Information
```{r ReadBarcodes}
barcodes.tsv <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/barcodes.tsv"
barcodes <- read.csv(barcodes.tsv, sep="\t", header = FALSE)
barcodes[1:5,]
```

`barcodes.tsv` is a CSV file that contains cell identifer and batch information. Chromium uses the actual cell barcodes as cell identifiers, and the number attached to each barcode sequence represents the batch it originated from.

Extract the batch numbers from the cell identifiers by splitting each string at the '-' symbol and retrieve the second part of the string. We can then link each cell barcode to its associated batch by transforming the vector into a named list.

```{r ProcessBatchID}
batch.information <- lapply(strsplit(as.character(barcodes$V1), "-"), `[`, 2)
names(batch.information) <- barcodes$V1
batch.information[1:5]
```

We can also add the cell identifiers to the expression matrix as column names.

```{r NameColumns}
colnames(expression.matrix) <- barcodes$V1
expression.matrix[1:5, 1:5]
```

#### Gene Annotation
```{r ReadGenes}
genes.tsv <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/genes.tsv"
gene.annotations <- read.csv(genes.tsv, sep="\t", header = FALSE)
colnames(gene.annotations) <- c("ensembl_id", "gene_name")
gene.annotations[1:5,]
```

`genes.tsv` contains the names of transcripts identified by Cell Ranger. As you can see, it lists ENSEMBL transcript IDs and their corresponding gene name. You can use either of these identifiers as row names for the expression matrix. 

For this tutorial, we will use gene names. As genes can have more than one transcript associated with them, we need to make the names unique before adding them to the expression matrix.

```{r SetRownames}
gene.names <- make.unique(as.vector(gene.annotations$gene_name))
rownames(expression.matrix) <- gene.names
expression.matrix[1:5, 1:5]
```

We can swap the gene names with ENSEMBL transcript IDs at a later stage as we will store the `genes` data frame in the `AEMSet`. We just need to update the `gene_name` column in the `genes` data frame with the unique gene names vector we have created.

```{r ReplaceGeneNames}
gene.annotations$gene_name <- gene.names
gene.annotations[1:15,]
```

#### Defining Controls
The last thing we need to do is to identify our controls. Usually, ribosomal and mitochondrial genes are used as controls for single-cell experiments. If used, spike-ins are also included as controls. For this tutorial, we will use ribosomal and mitochondrial genes as controls.

```{r DefineControls}
# Mitochondrial gene list from
mito.genes <- c("MT-ND1", "MT-ND2", "MT-ND3", "MT-ND4L", "MT-ND4", "MT-ND5", "MT-ND6", "MT-CYB", "MT-CO1", "MT-CO2", "MT-CO3", "MT-ATP6", "MT-ATP8", "MT-CYB")

# Ribosomal gene list from http://ribosome.med.miyazaki-u.ac.jp/
ribo.genes <- c("RPSA", "RPS2", "RPS3", "RPS3A", "RPS4X", "RPS5", "RPS6", "RPS7", "RPS8", "RPS9", "RPS10", "RPS11", "RPS12", "RPS13", "RPS14", "RPS15", "RPS15A", "RPS16", "RPS17", "RPS18", "RPS19", "RPS20", "RPS21", "RPS23", "RPS24", "RPS25", "RPS26", "RPS27", "RPS27A", "RPS28", "RPS29", "RPL3", "RPL4", "RPL5", "RPL6", "RPL7", "RPL7A", "RPL8", "RPL9", "RPL10", "RPL10A", "RPL11", "RPL12", "RPL13", "RPL13A", "RPL14", "RPL15", "RPL17", "RPL18", "RPL18A", "RPL19", "RPL21", "RPL22", "RPL23", "RPL23A", "RPL24", "RPL26", "RPL27", "RPL27A", "RPL28", "RPL29", "RPL30", "RPL31", "RPL32", "RPL34", "RPL35", "RPL35A", "RPL36", "RPL36A", "RPL37", "RPL37A", "RPL38", "RPL39", "RPL41", "RPLP0", "RPLP1", "RPLP2")

controls <- list(Mt = mito.genes, Rb = ribo.genes)

```

#### Building an AEMSet
Now that we have prepared the data, we can load it into an AEMSet.

```{r BuildAEMSet}
aem.set <- NewAEMSet(ExpressionMatrix = expression.matrix, GeneAnnotation = gene.annotations, BatchInformation = batch.information, Controls = controls)
aem.set
```

### Load data from Cell Ranger into ASCEND automatically
If you are using Chromium data, you can also load the data into R with this function.

```{r AutoLoading, eval = FALSE}
aem.set <- CellRangerToASCEND("/Users/a.senabouth/Data/t_3k_and_t_4k", "GRCh38")
```

This function loads the data into an AEMSet, with the assumption that mitochondrial and ribosomal genes are controls for this experiment.

## Single-cell post-processing and normalisation workflow
This workflow is based off [A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor][1] by Lun *et al* 2016. 

### Preliminary QC
Now that we have our data loaded, we can assess its quality through a series of plots generated by `PlotGeneralQC`. We will use these plots to guide our filtering. 

The resulting plots are stored in a named list. You can use the `PlotPDF` function to output the plots in this list to a PDF file.
```{r, echo=FALSE, fig.show='hide'}
raw.qc.plots <- PlotGeneralQC(aem.set)
PlotPDF(raw.qc.plots, "RawQC.pdf")
```


### Cell filtering 
#### Filtering cells by library size and genes expressed.
First we want to remove cells with library sizes that are too small or too large, as shown on the following plot.
```{r, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$LibSize)
```

We also want to remove cells that express express too many or too few genes, as shown on the following plot.
```{r, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$FeatureCountsPerCell)
```

And finally, we want to remove cells if they are expressing too few or too many control genes; for our tutorial, the controls are mitochondrial and ribosomal genes. The following plots show how many cells are expressing a certain percentage of mitochondrial and ribosomal genes.

```{r, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$ControlPercentageTotalCounts$Mt)
print(raw.qc.plots$ControlPercentageTotalCounts$Rb)
```

We can filter these cells out by using the `FilterByOutliers` function. The threshold arguments refer to the median absolute deviations (MADs) below the median. These are set to 3 by default, but you can adjust them if required.

```{r FilterByOutliers, echo = FALSE}
aem.set <- FilterByOutliers(aem.set, CellThreshold = 3, ControlThreshold = 3)
```

#### Filter cells by control gene expression
We removed a significant number of cells in the previous step that were expressing too many, or too few control genes. As ribosomal and mitochondrial genes are indicative of a stressed or dying cell, we need to perform some additional filtering and remove cells where they contribute to the bulk of the cell's expression. This can be seen on the following beehive plots.

```{r ControlPercentagePlots, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$ControlPercentageSampleCounts$Mt)
print(raw.qc.plots$ControlPercentageSampleCounts$Rb)
```

You can review your control list by using `GetControls`. As you can see, we have stored the mitochondrial genes under "Mt" and ribosomal genes under "Rb."

```{r RetrieveControls}
print(GetControls(aem.set))
```

We can use `FilterByCustomControl` to remove cells that are mostly expressing these genes. To use this function, we have to specify the name of the list of control genes and the minimum percentage expression to filter by.

```{r FilterByControl, echo = FALSE}
# Filter by mitochondrial genes
aem.set <- FilterByCustomControl("Mt", 20, aem.set)
# Filter by ribosomal genes
aem.set <- FilterByCustomControl("Rb", 50, aem.set)
```

You will need to remove the controls from all cells for some analyses. This is best done after normalisation.

#### Filtering by expression
The final step of filtering is to remove low-abundance genes. The average expression of genes can be reviewed on the AverageGeneCount plots.

```{r AverageGeneCountPlots, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$AverageGeneCount)
```

Due to the nature of single-cell RNASeq, many genes will have zero or near-zero expression. We can have a closer look at the distribution with the Log2 and Log10 Average Transcript Count plots. 

```{r AverageGeneCountLogPlots, fig.width=5, fig.height=4, fig.align="center"}
print(raw.qc.plots$Log2AverageGeneCount)
print(raw.qc.plots$Log10AverageGeneCount)
```

We will remove genes that have zero expression in at least a certain percentage of the cell population. In this case, we have chosen 1% of cells. 

```{r FilterByExpressedGenesPerCell}
aem.set <- FilterByExpressedGenesPerCell(aem.set, 0.01)
```

#### Filtering Review
We can review the impact of filtering on our dataset by running `PlotGeneralQC` again. `ASCEND` has also kept track of what changes were made to the dataset, and we can view this log with the function `DisplayLog`.

```{r CheckFiltering, echo = FALSE, results = "hide", fig.show="hide"}
filtered.qc.plots <- PlotGeneralQC(aem.set)
```
```{r, fig.width=5, fig.height=4, fig.align="center"}
print(filtered.qc.plots$LibSize)
print(filtered.qc.plots$FeatureCountsPerCell)
```

```{r CheckLogFiltering}
DisplayLog(aem.set)
```

##### PlotTopGeneExpression
We can also view the top expressed genes by using the function `PlotTopGeneExpression`. This function gets called by `PlotGeneralQC`, but in this case we want to exclude the controls and see only the top 10.

```{r PlotTopGeneExpression, fig.width=5, fig.height=4, fig.align="center"}
top.50.expression <- PlotTopGeneExpression(aem.set, n = 10, controls = FALSE)
print(top.50.expression)
```

### Normalisation
Normalisation needs to be done at two levels - between batches and between cells.

The ASCEND package contains the following normalisation functions:

* NormaliseBatches: Normalise library sizes between batches.
* NormaliseByRLE: Normalise library sizes between cells by Relative Log Expression (RLE).
* scranNormalise: Normalise library sizes between cells using *scran*'s deconvolution method.

How you use these functions depends on the dataset.

#### NormaliseBatches
Normalisation between batches needs to be done prior to filtering.

However, for this tutorial - we do not need to use the `NormaliseBatches` as this dataset was prepared with Cell Ranger's *aggr* pipeline. This pipeline uses a subsampling process to normalise between batches [(Zheng et al. 2017)][2].

We do need to normalise between cells so we can use one of the following functions: `NormaliseByRLE` or `scranNormalise`.

#### NormaliseByRLE
In this method, each cell is considered as one library and assumes that most genes are not differentially expressed. It uses gene expression values higher than 0 to calculate the geometric means of a gene. The geometric mean is the mean of the expression of the gene across all cells (for cells where the gene is detected). Each gene has one geometric mean value for all cell. For each cell, the gene expression values are divided by the geometric means to get one normalisation factor for a gene in that cell. The median of all the normalisation factors for all genes in that cell is the normalisation factor for the cell. Post RLE normalisation, a gene with 0 expression still has 0 expression. A gene with expression higher than 0 will have an expression value equal the raw expression divided by the calculated normalization factor for the cell. As spike-ins affect library size, they need to be removed prior to normalisation.

This method is relatively quick and can be run on a desktop.

```{r NormaliseByRLE}
norm.set <- NormaliseByRLE(aem.set)
```

#### scranNormalise
This function is a wrapper for the deconvolution method by [Lun et al. 2015][3] that uses the [scran][1] and [scater][3] packages. This method takes into account the high proportion of zero counts in single-cell data and tackles the zero-inflation problem by applying a pooling strategy to calculate size-factors of each pool. The pooled size factors are then deconvoluted to infer the size factor for each cell, which are used scale the counts within that cell. The [scran vignette][4] explains the whole process in greater detail.

If the dataset contains less than 10,000 cells, `scranNormalise` will run `scran`'s `computeSumFactors` function with preset sizes of 40, 60, 80 and 100. For larger datasets, `scranNormalise` will run `quickCluster` before `computeSumFactors`.

This method is computationally intensive; we do not recommend running datasets larger than 5000 cells on a desktop machine. Datasets larger than 10,000 cells should be run on a HPC.

To ensure compatibility with `scran` and `scater`, the `AEMSet` needs to have mitochondrial and ribosomal genes as controls. The control list also needs to be formatted as follows:

```{r}
print(GetControls(aem.set))
```

You can then use the function.

```{r scranNormalise, eval = FALSE}
norm.set <- scranNormalise(aem.set)
```

#### Reviewing the normalisation process
We can examine the impact of the normalisation methods by comparing the normalised object to the un-normalised object.

```{r PlotNormalisationQC}
norm.qc <- PlotNormalisationQC(original = aem.set, normalised = norm.set, gene.list = c("GAPDH", "ACTB"))
```

We can review how normalisation has affected the library sizes with the library size histograms. The `NormaliseByRLE` method does not affect library size as drastically as the scranNormalise method; instead, the changes are more apparent on a gene level.

```{r NormLibsizePlot, fig.show = "hold", fig.align="center"}
print(norm.qc$Libsize$Original)
print(norm.qc$Libsize$Normalised)
```

For example, here are the expression levels of GAPDH before and after normalisation.
```{r NormGAPDH,fig.show = "hold", fig.align="center"}
print(norm.qc$GeneScatterPlots$GAPDH$Original)
print(norm.qc$GeneScatterPlots$GAPDH$Normalised)
```

The differences are more apparent with ACTB.

```{r NormACTB}
print(norm.qc$GeneScatterPlots$ACTB$Original)
print(norm.qc$GeneScatterPlots$ACTB$Normalised)
```

The changes to overall gene expression can also be reviewed on gene expression boxplots.

```{r NormGenes}
print(norm.qc$GeneExpressionBoxplot$Original)
print(norm.qc$GeneExpressionBoxplot$Normalised)
```


### Control Removal
As we can see from the top 20 expressed genes plot, ribosomal genes dominate expression.

```{r ControlRemovalPlot1, fig.width = 5, fig.height = 4, fig.align="center"}
top.20.plot <- PlotTopGeneExpression(aem.set, n = 20, controls = TRUE)
print(top.20.plot)
```

For our tutorial, we are interested in other genes so we will remove the controls from the dataset.

```{r ExcludeControls}
aem.set <- ExcludeControl(aem.set, "Mt")
aem.set <- ExcludeControl(aem.set, "Rb")
```

This will reveal other genes that might be interesting.

```{r ControlRemovalPlot2, fig.width = 5, fig.height = 4, fig.align="center"}
top.20.plot <- PlotTopGeneExpression(aem.set, n = 20, controls = TRUE)
print(top.20.plot)
```

### Dimension Reduction
We have filtered our dataset down to 6100 cells and 33604 genes. We can reduce this dataset further by using *Principal Component Analysis (PCA)* to identify genes that are major contributors to variation.

```{r DimReduction1}
aem.set <- RunPCA(aem.set)
```

We need to determine how many principal components (PCs) to keep. `PlotPCAVariance` generates what is known as a *scree plot*, which depicts what percentage each PC contributes to the total variance of the data.

```{r PlotPCAVariance}
pca.variance <- PlotPCAVariance(aem.set, 50)
print(pca.variance)
```

The scree plot shows most of the variance in the dataset is due to the top 20 PCs. Therefore, the dataset can be reduced further by retaining only these PCs.

```{r ReduceDimensions}
aem.set <- ReduceDimensions(aem.set, 20)
```

#### Plotting dimension-reduced data
Dimension reduction is often used to reduce a dataset to dimensions that can be plotted.

##### PCA Plot
```{r PlotPCA}
batch.info <- GetBatchInfo(aem.set)
pca.plot <- PlotPCA(aem.set, condition.list = batch.info)
print(pca.plot)
```

##### Dimension reduction via t-Distributed Stochastic Neighbour Embedding (TSNE)

tSNE plots can be used only for the purpose of displaying results from other independent analysis such as clustering results from our ASCEND pipeline or normlized gene expression results. tSNE plots often show good separation of clusters (identified by other methods independent of tSNe), but the distance between cells and clusters should not be intepreted as the relative difference between them.

sually, this method is computationally intensive but as we have reduced our dataset via PCA, we can simply run Rtsne's TSNE function on the reduced matrix. This reduces all the information into the number of dimensions of your own choosing.

The function also takes arguments to pass on to the Rtsne function, such as perplexity and theta. If you wish to reproduce the plot at a later stage, you can set a seed value.

```{r PlotTSNE}
tsne.plot <- PlotTSNE(aem.set, PCA = TRUE, condition.list = batch.info, seed = 0, perplexity = 30, theta = 0.5)
print(tsne.plot)
```

##### MDS Plot
```{r PlotMDS}
mds.plot <- PlotMDS(aem.set, PCA = TRUE, condition.list = batch.info)
print(mds.plot)
```

### Clustering

```{r FindOptimalClusters}
aem.set <- FindOptimalClusters(aem.set)
```


```{r PlotStabilityDendro}
PlotStabilityDendro(aem.set)
```


```{r PlotDendrogram}
PlotDendrogram(aem.set)
```

### Differential Expression
#### Batch vs Batch
```{r RunDiffExpression}
batch.info <- GetBatchInfo(aem.set)
batch.de.result <- RunDiffExpression(aem.set, condition.a = "1", condition.b = "2", condition.list = batch.info)
```

#### Cluster vs Cluster
```{r RunClusterDiffExpression}
cluster.de.result <- RunClusterDiffExpression(aem.set)

```

## References
[1]: https://f1000research.com/articles/5-2122/v2
Lun ATL, McCarthy DJ and Marioni JC. A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor [version 2; referees: 3 approved, 2 approved with reservations]. F1000Research 2016, 5:2122 (doi: 10.12688/f1000research.9501.2)

[2]: https://www.nature.com/articles/ncomms14049
Zheng, G. X. Y. et al. Massively parallel digital transcriptional profiling of single cells. Nat. Commun. 8, 14049 doi: 10.1038/ncomms14049 (2017).

[3]: https://bioconductor.org/packages/release/bioc/html/scater.html
McCarthy DJ, Campbell KR, Lun ATL and Wills QF (2017). “Scater: pre-processing, quality control, normalisation and visualisation of single-cell RNA-seq data in R.” Bioinformatics, 14 Jan. doi: 10.1093/bioinformatics/btw777, http://dx.doi.org/10.1093/bioinformatics/btw777.

[4]: https://bioconductor.org/packages/release/bioc/vignettes/scran/inst/doc/scran.html
