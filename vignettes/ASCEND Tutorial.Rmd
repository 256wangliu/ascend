---
title: "An introduction to ASCEND - Analysis of Single Cell Expression, Normalisation and Differential expression"
author: "Anne Senabouth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ASCEND Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `ASCEND` package provides a series of tools for the processing and analysis of single cell RNA-seq (scRNA-seq) in R. These tools performs tasks such as filtering, normalisation, clustering and differential expression.

## Before you begin
### System Requirements
Datasets produced by scRNASeq experiments are very large, ranging from a few hundred to a million cells. The number of cells affect how much computational resources are required to process the dataset. Therefore, you need to determine if you have enough computational power and time to complete the analysis. ASCEND can comfortably analyse datasets of up to 10000 cells on a single machine with 8GB of RAM and a quad-core CPU. Datasets larger than this should be run on a high performance cluster (HPC).

### Configuring BiocParallel
This package makes extensive use of [BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html), enabling ASCEND to make the most of your computer's hardware. As each system is different, BiocParallel needs to be configured by the user. Here are some example configurations.

#### Unix/Linux/MacOS (Single Machine)
```{r SetupNix, eval = TRUE}
library(BiocParallel)
ncores <- parallel::detectCores() - 1
register(MulticoreParam(workers = ncores, progressbar=TRUE), default = TRUE)
```

#### Windows (Single Machine - Quad-core system)
```{r SetupWin, eval = FALSE}
library(BiocParallel)
workers <- 3 # Number of cores on your machine - 1
register(SnowParam(workers = workers, type = "SOCK", progressbar = TRUE), default = TRUE)
```

#### Cluster (PBSPro)
```{r SetupCluster, eval = FALSE}
library(BiocParallel)
library(Rmpi)
# Rmpi code here
```

#### Loading ASCEND
As this package is still under development, please use devtools to load the package.

```{r LoadASCEND}
devtools::load_all("/Users/a.senabouth/Code Repositories/ASCEND")
```

You can also use devtools' install_github function to install the package. You can then load the package as normal.

```{r LoadASCENDGit, eval = FALSE}
devtools::install_github("MB-Computational-Genomics-Lab/ASCEND")
```

## Loading Data for use in ASCEND
### Preparing data manually
The vignette uses the public dataset ["Aggregate of t_3k and t_4k"](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.0.1/t_3k_4k_aggregate) by 10x Genomics. This dataset consists of 8093 pan T cells that are divided into two batches. The cells were isolated from a healthy donor.

You can download the dataset from [here](http://cf.10xgenomics.com/samples/cell-exp/1.3.0/t_3k_4k_aggregate/t_3k_4k_aggregate_filtered_gene_bc_matrices_mex.tar.gz).


The **Gene / cell matrix (filtered)** download contains the following files:

- barcodes.tsv
- genes.tsv
- matrix.mtx

These files contain all the information we need to create an `AEMSet` - the main data object of the ASCEND package. 

#### Expression matrix
The main source of input is an expression matrix, or a gene/cell matrix containing transcript counts. Each row represents a gene and each column represents a cell. Cell Ranger - the processing pipeline for the Chromium platform, has stored the expression matrix in a Market Exchange Format (MEX) file called `matrix.mtx`. We need to use the `readMM` function from the `Matrix` package to load the data into R.

```{r ReadExpressionMatrix}
library(Matrix)
matrix.mtx <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/matrix.mtx"
expression.matrix <- readMM(matrix.mtx)
expression.matrix <- as.data.frame(as.matrix(expression.matrix))
expression.matrix[1:5,1:5]
```

`readMM` reads the data in as a sparse matrix. This format uses less memory than data frames and matrices. We have converted the expression matrix into a data frame so we can view its contents. As you can see, there column and row labels aren't very helpful. This is because Cell Ranger has stored them in the two other files - `barcodes.tsv` and `genes.tsv`.

#### Cell Identifiers and Batch Information
```{r ReadBarcodes}
barcodes.tsv <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/barcodes.tsv"
barcodes <- read.csv(barcodes.tsv, sep="\t", header = FALSE)
barcodes[1:5,]
```

`barcodes.tsv` is a CSV file that contains cell identifer and batch information. Chromium uses the actual cell barcodes as cell identifiers, and the number attached to each barcode sequence represents the batch it originated from.

Extract the batch numbers from the cell identifiers by splitting each string at the '-' symbol and retrieve the second part of the string. We can then link each cell barcode to its associated batch by transforming the vector into a named list.

```{r ProcessBatchID}
batch.information <- lapply(strsplit(as.character(barcodes$V1), "-"), `[`, 2)
names(batch.information) <- barcodes$V1
batch.information[1:5]
```

We can also add the cell identifiers to the expression matrix as column names.

```{r NameColumns}
colnames(expression.matrix) <- barcodes$V1
expression.matrix[1:5, 1:5]
```

#### Gene Annotation
```{r ReadGenes}
genes.tsv <- "/Users/a.senabouth/Data/t_3k_and_t_4k/outs/filtered_gene_bc_matrices_mex/GRCh38/genes.tsv"
gene.annotations <- read.csv(genes.tsv, sep="\t", header = FALSE)
colnames(gene.annotations) <- c("ensembl_id", "gene_name")
gene.annotations[1:5,]
```

`genes.tsv` contains the names of transcripts identified by Cell Ranger. As you can see, it lists ENSEMBL transcript IDs and their corresponding gene name. You can use either of these identifiers as row names for the expression matrix. 

For this tutorial, we will use gene names. As genes can have more than one transcript associated with them, we need to make the names unique before adding them to the expression matrix.

```{r SetRownames}
gene.names <- make.unique(as.vector(gene.annotations$gene_name))
rownames(expression.matrix) <- gene.names
expression.matrix[1:5, 1:5]
```

We can swap the gene names with ENSEMBL transcript IDs at a later stage as we will store the `genes` data frame in the `AEMSet`. We just need to update the `gene_name` column in the `genes` data frame with the unique gene names vector we have created.

```{r ReplaceGeneNames}
gene.annotations$gene_name <- gene.names
gene.annotations[1:15,]
```

#### Defining Controls
The last thing we need to do is to identify our controls. Usually, ribosomal and mitochondrial genes are used as controls for single-cell experiments. If used, spike-ins are also included as controls. For this tutorial, we will use ribosomal and mitochondrial genes as controls.

```{r DefineControls}
# Mitochondrial gene list from
mito.genes <- c("MT-ND1", "MT-ND2", "MT-ND3", "MT-ND4L", "MT-ND4", "MT-ND5", "MT-ND6", "MT-CYB", "MT-CO1", "MT-CO2", "MT-CO3", "MT-ATP6", "MT-ATP8", "MT-CYB")

# Ribosomal gene list from http://ribosome.med.miyazaki-u.ac.jp/
ribo.genes <- c("RPSA", "RPS2", "RPS3", "RPS3A", "RPS4X", "RPS5", "RPS6", "RPS7", "RPS8", "RPS9", "RPS10", "RPS11", "RPS12", "RPS13", "RPS14", "RPS15", "RPS15A", "RPS16", "RPS17", "RPS18", "RPS19", "RPS20", "RPS21", "RPS23", "RPS24", "RPS25", "RPS26", "RPS27", "RPS27A", "RPS28", "RPS29", "RPL3", "RPL4", "RPL5", "RPL6", "RPL7", "RPL7A", "RPL8", "RPL9", "RPL10", "RPL10A", "RPL11", "RPL12", "RPL13", "RPL13A", "RPL14", "RPL15", "RPL17", "RPL18", "RPL18A", "RPL19", "RPL21", "RPL22", "RPL23", "RPL23A", "RPL24", "RPL26", "RPL27", "RPL27A", "RPL28", "RPL29", "RPL30", "RPL31", "RPL32", "RPL34", "RPL35", "RPL35A", "RPL36", "RPL36A", "RPL37", "RPL37A", "RPL38", "RPL39", "RPL41", "RPLP0", "RPLP1", "RPLP2")

controls <- list(Mt = mito.genes, Rb = ribo.genes)

```

#### Building an AEMSet
Now that we have prepared the data, we can load it into an AEMSet.

```{r BuildAEMSet}
aem.set <- NewAEMSet(ExpressionMatrix = expression.matrix, GeneAnnotation = gene.annotations, BatchInformation = batch.information, Controls = controls)
aem.set
```

### Load data from Cell Ranger into ASCEND automatically
If you are using Chromium data, you can also load the data into R with this function.

```{r AutoLoading, eval = FALSE}
aem.set <- CellRangerToASCEND("/Users/a.senabouth/Data/t_3k_and_t_4k", "GRCh38")
```

This function loads the data into an AEMSet, with the assumption that mitochondrial and ribosomal genes are controls for this experiment.

## Single-cell post-processing and normalisation workflow
### Preliminary QC
Now that we have our data loaded, we can assess its quality through a series of plots generated by `PlotGeneralQC`. These plots are stored in a named list.
```{r, echo=FALSE, fig.show='hold'}
raw.qc.plots <- PlotGeneralQC(aem.set)
print(raw.qc.plots$LibSize)
print(raw.qc.plots$FeatureCountsPerCell)
```

## Helpful Vignette Comments

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
