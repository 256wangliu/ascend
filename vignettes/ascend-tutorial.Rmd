---
title: "An introduction to 'ascend' (Analysis of Single Cell Expression, Normalisation and Differential expression)"
author: "Anne Senabouth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to 'ascend' (Analysis of Single Cell Expression, Normalisation and Differential expression)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ascend)
data(datasets)
RawSet <- datasets$RawSet
EMSet <- datasets$CompleteSet
```

## 1. Introduction
The `ascend` R package provides simple, robust tools for the processing and 
analysis of data generated by single cell RNA sequencing (scRNA-seq). Summarized
in Figure 1, the following stages of scRNA-seq analysis workflows can be 
performed with `ascend`:

1. Quality control
2. Normalisation
  + Between batches
  + Within batches
  + Between cells
3. Dimensionality reduction
4. Clustering
5. Differential expression

This vignette provides general overview of the `ascend` R package.

Other vignettes cover the following topics:

1. Installation of `ascend` and package dependancies
2. Analysis of retina ganglion cells with `ascend`
3. `ascend` tips and tricks

## 2. Preparing data for use with 'ascend'

The main source of input is an expression matrix, or a gene-barcode matrix 
containing transcript counts. Columns represent individual cells, while rows 
represent genes. Expression matrices are usually the endpoint of scRNA-seq 
processing pipelines. Data generated by Chromium, DropSeq and inDrop have been
tested with this package.

`ascend` is able to use any row and column names in the expression matrix, 
provided they abide by the following criteria:

1. Names should not repeat. If you have a list with repeats, you can make the 
names unique by using R's 'make.unique' function.
2. You should be able to identify which genes you would like to select as 
controls. This is why gene names are preferred.

It is beneficial to prepare cell and gene information to accompany the 
expression matrix. 

Cell information should be loaded into a data frame containing cell identifiers
in the first column (cell_barcode), the name of the batch the cell was sequenced 
in (batch) in the second column, and additional information such as experimental 
conditions in subsequent columns. 

This data frame should be structured as follows:

```{r cell_info_knitr}
knitr::kable(data.table::data.table(
  cell_barcode = c("Cell1-1", "Cell2-1", "...", "...", "Cellx-x"), 
  batch = c("1", "1", "...", "...", "x")))
```

`ascend` will prepare this data frame for you if none is supplied, but will
assume all cells belong to a single batch.

Gene information should be loaded into a dataframe containing the gene 
identifiers used in the expression matrix in the first column, followed by
other information. If you need to access other packages that use different
gene identifiers (eg. ENSEMBL gene identifiers for cyclone), you can store these
identifiers in the data frame and switch the dataset to that set of identifiers
using the `convertGeneID` function.

This data frame should be structured as follows:

```{r gene_info_knitr}
knitr::kable(data.table::data.table(
  gene_identifier1 = c("GENE1", "GENE2", "...", "...", "GENEX"), 
  gene_identifier2 = c("IDENTIFIER1", "IDENTIFIER2", "...", "...", 
                                      "IDENTIFIERX")))
```

`ascend` will also prepare this data frame for you if none is supplied, but
it will only contain the gene identifiers used in the expression matrix.

## 2.1 Controls
You may define genes as controls. It is required if you would like to use 
`ascend`'s filtering functions. Controls are usually mitochondrial and ribosomal
genes, but can also include spike-ins if they were included in the study.

Controls should be organised into groups of control types and in a named list,
and the genes must be present in the expression matrix.

```{r set_controls, eval = FALSE}
# Example controls
controls <- list(Mt = grep("^Mt-", rownames(expression_matrix), ignore.case = TRUE)
                 Rb = grep("^Rps|^Rpl", rownames(expression_matrix), ignore.case = TRUE)
```

## 3. The Expression and Metadata Set (EMSet)
The core of the `ascend` R package is the Expression and Metadata Set (EMSet). 
This object stores user-supplied data in the form of a gene-cell expression 
matrix generated by any scRNA-seq platform, in addition to metadata such as 
cell- or gene-related information. Information generated by `ascend`'s 
analytical functions are stored in the EMSet and are accessed by downstream 
functions. Operations are logged within the object and users may review quality 
control metrics that are updated every time a change is made to the count 
matrix.

The EMSet extends the SingleCellExperiment superclass from Bioconductor ensuring
all layers of the object remain synchronized and users have access to 
specialized methods for data access. This also enables integration into other 
single cell analytical workflows; an EMSet can be created from a 
SingleCellExperiment object, and an EMSet can be converted into a 
SingleCellExperiment. Convenience functions are supplied to ensure all 
information stored in an EMSet are preserved upon conversion.

### 3.1 Structure
An EMSet consists of the following slots and information:

1. **assays**: A list assays, each containing a representation of the count data.
Raw counts are loaded into and stored in the *counts* assay. Counts normalised 
within the `ascend` environment are stored in the *normcounts* assay, and the 
log-transformed normalised values are stored in the *logcounts* assay.
2. **colInfo**: Cell-related metadata supplied by the user and additional
metadata generated by `ascend`.
3. **colData**: Cell-related data generated by `ascend`, such as cell-related
quality control metrics.
4. **rowInfo**: Gene-related metadata supplied by the user and additional
metadata generated by `ascend`.
5. **rowData**: Gene-related data generated by `ascend`, such as gene-related
quality control metrics.
6. **reducedDims**: Dimensionality reduced versions of the dataset. `ascend`
offers dimensionality reduction via Principal Component Analysis (PCA) and
t-Distributed Stochastic Neighbourhood Embedding (t-SNE).
7. **clusterAnalysis**: Clustering-related outputs generated by the SCORE
algorithm, such as a distance matrix, hclust object, Rand matrix and cluster
identities.
8. **log**: A record of functions used on an EMSet, in addition to genes and
cells removed by functions.

### 3.2 Creating an EMSet
An EMSet can be created with the `newEMSet` function. As the EMSet is built off 
the SingleCellExperiment class, users may load assays that are stored in a pre-
existing SingleCellExperiment object into this function.

```{r load_data, eval = FALSE}
# Creating an EMSet from scratch
em_set <- newEMSet(assays = list(counts = expression_matrix),
                   colInfo = col_info_data_frame,
                   rowInfo = row_info_data_frame,
                   controls = control_list)

# Loading an EMSet from a SingleCellExperiment
em_set <- newEMSet(SingleCellExperiment, 
                   colInfo = col_info_data_frame,
                   rowInfo = row_info_data_frame,
                   controls = control_list)
                   
```

Refer to the [Analysis of retina ganglion cells with ascend](link) vignette for 
more information on how to prepare and load data into an EMSet.

### 3.3 Manipulating an EMSet
An EMSet is organised as layers of information accessible via functions. These
functions can be used to get and set elements of an EMSet.

```{r get_set_examples}
# Get assays
count_matrix <- counts(EMSet)
norm_matrix <- normcounts(EMSet)
logcounts_matrix <- logcounts(EMSet)

# Set assays
counts(EMSet) <- count_matrix
normcounts(EMSet) <- norm_matrix
logcounts(EMSet) <- logcounts_matrix

# Get gene and cell information
col_info <- colInfo(EMSet)
col_data <- colData(EMSet)
row_info <- rowInfo(EMSet)
row_data <- rowData(EMSet)

# Set gene and cell information
colInfo(EMSet) <- col_info
colData(EMSet) <- col_data
rowInfo(EMSet) <- row_info
rowData(EMSet) <- row_data

# Get reduced dimensionality data
tsne_matrix <- reducedDim(EMSet, "TSNE")
pca_matrix <- reducedDim(EMSet, "PCA")

# Get cluster analysis
clusterAnalysis <- clusterAnalysis(EMSet)

# Get progress log
progressLog <- progressLog(EMSet)
```

The EMSet can also be treated as as a data frame through the use of row/column 
accessors.

```{r dataframe_accesors}
# Reduce EMSet to first ten cells and genes
tiny_EMSet <- EMSet[1:10,1:10]

# Review content in smaller dataset 
print(counts(tiny_EMSet))
print(colInfo(tiny_EMSet))
print(rowInfo(tiny_EMSet))
```

The subgroups within the EMSet can also be subsetted from the EMSet with the
`subsetCondition` function. The condition needs to be set in the colInfo slot.

```{r subsetCondition}
# Subset batch 1 from the combined EMSet
Batch1_EMSet <- subsetCondition(EMSet, by = "batch", conditions = list(batch = c(1)))
```

## 4. Visualising with 'ascend'
Most plots in `ascend` are generated via the ggplot2 package. These plots can be
modified further by the user with ggplot2 functions, as described in the [package
documentation](http://ggplot2.tidyverse.org/reference/).

| Function                | Description                                                                                                                                                                                                                        |
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| plotGeneralQC           | Generates a list of quality control plots                                                                                                                                                                                          |
| plotLibsizeBarplot      | Called by plotGeneralQC. Generates a barplot representing number of reads per cell.                                                                                                                                                |
| plotLibsizeHist         | Called by plotGeneralQC. Generates a histogram representing the number of cells with a specific library size.                                                                                                                      |
| plotAverageGeneCount    | Called by plotGeneralQC. Generates a histogram representing the number of genes with a specific average expression level.                                                                                                          |
| plotTopGenesBoxplot     | Called by plotGeneralQC. Generates a series of boxplots representing the expression of the top most abundant genes.                                                                                                                |
| plotTopGenesPerSample   | Called by plotGeneralQC. Generates a beeswarm-violin plot for each sample that represents the relationship between the counts of the top 500 most expressed genes and the top 100 most expressed genes.                            |
| plotFeatureHist         | Called by plotGeneralQC if controls are defined. Histogram of non-control counts associated with each cell.                                                                                                                        |
| plotGeneNumber          | Called by plotGeneralQC if controls are defined. Histogram of non-control genes associated with each cell.                                                                                                                         |
| plotControlHist         | Called by plotGeneralQC. Generates a histogram of the percentage of control gene expression for each cell.                                                                                                                         |
| plotControlPctPerSample | Called by plotGeneralQC. Generates a beeswarm-violin plot representing the proportion of control-associated genes to whole expression of each gene.                                                                                |
| plotNormQC              | Generates plots for the quality control of normalised data. Plots include a histogram for pre-normalised and normalised library sizes, scatter boxplots for selected genes and scatter boxplots for counts sampled from 100 genes. |
| plotPCAVariance         | Generates a scree plot of percentage variance of genes, sorted from largest to smallest.                                                                                                                                           |
| plotPCA                 | Generates a scatter plot based off the PCA matrix.                                                                                                                                                                                 |
| plotTSNE                | Generates a scatter plot based off the TSNE matrix.                                                                                                                                                                                |
| plotMDS                 | Generates a scatter plot based of MDS values derived from the PCA matrix and distance matrix.                                                                                                                                      |
| plotStabilityDendro     | Generates a dendrogram with coloured bars representing stability. DOES NOT USE GGPLOT2.                                                                                                                                            |
| plotStability           | Generates a line graph representing stability, consecutive index and Rand index.                                                                                                                                                   |
| plotDendrogram          | Generates a colour-labelled dendrogram with cluster sizes added. DOES NOT USE GGPLOT2.                                                                                                                                             |
| plotVolcano             | Generates a volcano plot (scatter plot) using output generated by the differential expression functions of the ascend package.                                                                                                     |
| plotVariableGenes       | Generates a scatter plot to aid in the detection of variable genes.                                                                                                                                                                |
### 4.1 Example plots - t-SNE
t-SNE plots are a popular way to visualise scRNA-seq data. As t-SNE plots are 
best used in conjunction with information generated from other analysis, the
plotTSNE function in `ascend` can use information stored in the colInfo slot
label cells.

Before we can generate a t-SNE plot, we need to reduce the data with the method.
We will supply the `runTSNE` function with a seed value as we may want to 
replicate this analysis.

```{r runTSNE}
EMSet <- runTSNE(EMSet, seed = 1)
```

We can then use `plotTSNE` to visualise the clusters we identified via the
runCORE function.

```{r plotTSNE, fig.width = 6, fig.height = 5}
tsne_plot <- plotTSNE(EMSet, group = "cluster")
tsne_plot
```

As the t-SNE plot was generated via ggplot2, we can use ggplot2 functions to
modify the graph. In this case, we want to change the colours of the clusters.

```{r colour_tsne, fig.width = 6, fig.height = 5}
library(ggplot2)
tsne_plot <- tsne_plot + scale_color_manual(values=c("#bb5f4c", 
                                                     "#8e5db0", 
                                                     "#729b57"))
tsne_plot
```

## 5. Using 'ascend' with other packages
Many Bioconductor packages that are dedicated to scRNA-seq analysis use classes
that are related to the SingleCellExperiment class. As the EMSet contains 
additional information, we have provided a conversion function `EMSet2SCE`that 
preserves this information within a SingleCellExperiment object. The resulting 
SingleCellExperiment object can then be reverted to the EMSet using the 
`SCE2EMSet` function.

```{r convert2SCE}
# Convert to SingleCellExperiment
SingleCellExperiment <- EMSet2SCE(EMSet)

# Revert to SingleCellExperiment
EMSet <- SCE2EMSet(SingleCellExperiment)

```

## 5.1 Third-party wrappers
We have created wrappers for specific tasks in `scran`, `DESeq` and `DESeq2`.
They provide alternatives for specific stages in the `ascend` workflow and 
provide more in-depth analysis.

### 5.1.1 scran
#### 5.1.1.1 scran normalisation by deconvolution
This method is regarded as an advanced normalisation method for scRNA-seq data.
This method groups the cells into pools for size factor calculation before they
are applied to the dataset.

```{r scran_normalisation}
scran_normalised <- scranNormalise(RawSet, quickCluster = FALSE, min.mean = 1e-05)
```

#### 5.1.1.2 scran cell cycle
As the *Homo sapiens* training dataset that comes with scran uses ENSEMBL gene
identifiers, we need to convert the EMSet's gene identifiers to them.
Fortunately, we have retained these in rowInfo under the "ensembl_gene_id" 
column.

```{r scran_cellcycle, eval = FALSE}
# Convert identifiers to ENSEMBL gene identifiers
ensembl_set <- convertGeneID(RawSet, new.annotation = "ensembl_gene_id")

# Load training data from scran
training_data <- readRDS(system.file("exdata", "human_cycle_markers.rds", 
                                     package = "scran"))

# Run cell cycle
scran_cellcycle <- scranCellCycle(ensembl_set, training_set = training_data)

# Show cell cycle results
colInfo(scran_cellcycle)
```

### 5.1.2 DESeq
We have included wrappers for DESeq as the differential expression analysis 
for our earlier scRNA-seq datasets were preformed with this package. We found 
the results were comparable with other methods. Our optimisations have 
decreased the runtime of this package as well.

```{r DESeq, eval = FALSE}
cluster2_vs_others <- runDESeq(EMSet, group = "cluster",
                               condition.a = 2, condition.b = c(1, 3),
                               ngenes = 1500)
```

### 5.1.3 DESeq2
We have also included wrappers for DESeq2 on request. This package requires
substantially more time to run.

```{r DESeq2, eval = FALSE}
cluster1_vs_others <- runDESeq2(EMSet, group = "cluster",
                               condition.a = 1, condition.b = c(2, 3),
                               ngenes = 1500)
```