---
title: "ASCEND to the MAX - how to get the most out of the ASCEND package"
author: "Anne Senabouth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ASCEND to the MAX - how to get the most out of the ASCEND package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Before you begin
### System Requirements
Datasets produced by scRNASeq experiments are very large, ranging from a few hundred to a million cells. The number of cells affect the amount of computational resources required to process the dataset â€“ therefore, you need to determine if you have enough computational power and time to complete the analysis. ASCEND can comfortably analyse datasets of up to 10,000 cells on a single machine with 8GB of RAM and a quad-core CPU. Larger datasets should be run on a High Performance Cluster (HPC).

We have tested this package with datasets ranging from 100 to 20,000 cells. Generally, increasing the number of cpus will decrease the processing time of functions, while larger datasets require more RAM. 

### Configuring BiocParallel
This package makes extensive use of [BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html), enabling ASCEND to make the most of your computer's hardware. As each system is different, BiocParallel needs to be configured by the user. Here are some example configurations.

#### Unix/Linux/MacOS (Single Machine)
```{r SetupNix, eval = TRUE}
library(BiocParallel)
ncores <- parallel::detectCores() - 1
register(MulticoreParam(workers = ncores, progressbar=TRUE), default = TRUE)

```

#### Windows (Single Machine - Quad-core system)
```{r SetupWin, eval = FALSE}
library(BiocParallel)
workers <- 3 # Number of cores on your machine - 1
register(SnowParam(workers = workers, type = "SOCK", progressbar = TRUE), default = TRUE)
```

### Installation
#### Required packages
ASCEND requires the following packages:

##### CRAN
* [devtools](https://cran.r-project.org/web/packages/devtools)
* [Matrix](https://cran.r-project.org/web/packages/Matrix)
* [ggplot2](https://cran.r-project.org/web/packages/ggplot2)
* [data.table](https://cran.r-project.org/web/packages/data.table)
* [dplyr](https://cran.r-project.org/web/packages/dplyr)
* [reshape2](https://cran.r-project.org/web/packages/reshape2)
* [Rtsne](https://cran.r-project.org/web/packages/Rtsne)
* [limSolve](https://cran.r-project.org/web/packages/limSolve)
* [ggbeeswarm](https://cran.r-project.org/web/packages/ggbeeswarm)
* [dynamicTreeCut](https://cran.r-project.org/package=dynamicTreeCut)
* [dendextend](https://cran.r-project.org/web/packages/dendextend)
* [RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer)

##### Bioconductor
* [Biobase](http://bioconductor.org/packages/release/bioc/html/Biobase.html)
* [BiocParallel](http://bioconductor.org/packages/release/bioc/html/BiocParallel.html)
* [scater](http://bioconductor.org/packages/release/bioc/html/scater.html)
* [scran](http://bioconductor.org/packages/release/bioc/html/scran.html)
* [DESeq](http://bioconductor.org/packages/release/bioc/html/DESeq.html)

Please install these packages before installing ASCEND. You do not need to load these packages when you work with ASCEND unless you are using functions directly from these packages (eg. BiocParallel).

#### Installing and loading ASCEND
Please use `devtools` to load the development version of `ASCEND`.

```{r LoadASCEND}
devtools::load_all("/Users/a.senabouth/CodeRepositories/ASCEND")
```

You can also use devtools' `install_github` function to install the package, and then load it as normal.

```{r LoadASCENDGit, eval = FALSE}
devtools::install_github("IMB-Computational-Genomics-Lab/ASCEND")
library(ASCEND)
```

## Preparing Data for ASCEND
This package has been tested with scRNASeq data generated by Chromium and DropSeq/FlowSeq. Data generated by other systems can be used with this package, provided the input is in the form of an expression matrix. The following section will describe how the data should be formatted.

### Expression Matrix
The main source of input is an expression matrix, or a gene-barcode matrix containing transcript counts. They are usually produced at the end of single cell RNA-seq processing pipelines such as Cell Ranger and DropSeq.

In an expression matrix, each row represents a gene and each column represents a cell. The names of rows and columns will subsequently be named accordingly.

ASCEND is able to use any row and column names in the expression matrix, provided they abide by the following criteria:

1. Names should not repeat. If you have a list with repeats, you can make the names unique by using R's 'make.unique' function.
2. You should be able to identify which genes you would like to select as controls. This is why gene symbols or ENSEMBL transcript IDs should be used.
3. Cells from different batches, samples or sequencing runs should be given a numeric identifier at the end. eg. BARCODE-1, BARCODE-2, BARCODE-3.

#### Combining expression matrices from different batches
You can concatenate multiple expression matrices with the function *MergeExprsMtx*. Expression matrices generated with this method should then be normalised with the *NormaliseBatches* function. For pipelines such as Chromium's Cell Ranger, the native aggregation function should be used as it takes into account additional information such as individual reads.

### Cell Information
Cell Information is a data frame containing cell identifiers, their associated batch identifier and additional information. ASCEND will automatically generate batch information for an expression matrix if none are provided. However, it will make the assumption that there is only one batch of cells in the expression matrix.

The Cell Information data frame should be structured as follows:

```{r echo = FALSE, results = "asis"}
library(knitr)
kable(data.table(cell_barcode = c("Cell1-1", "Cell2-1", "...", "...", "Cellx-x"), batch = c("1", "1", "...", "...", "x")))
```

Column 1 should hold the cell identifiers, and column 2 should hold batch information.

### Gene Information
The Gene Information slot holds a data frame that contains the gene identifiers used in the expression matrix, in addition to their corresponding identifiers in other systems. ASCEND will also automatically generate batch information based on the expression matrix if none are provided. The Gene Information data frame can also hold additional information about genes.

The Gene Information data frame should be structured as follows:

```{r echo = FALSE, results = "asis"}
library(knitr)
kable(data.table(gene_identifier1 = c("GENE1", "GENE2", "...", "...", "GENEX")))
```

### Controls
You must provide a list of gene identifiers linked to controls, if you would like to use ASCEND's filtering functions. These are generally mitochondrial and ribosomal genes. Spike-ins are also used as controls if they were included in the study.

Controls should be organised into a named list, and identifiers used should be present in the expression matrix.

## ASCEND Expression and Metadata Set - AEMSet
### Structure
An ASCEND Expression and Metadata Set (AEMSet) is a S4 object that stores information generated and used by the ASCEND package. This object contains 7 slots which are as follows:

* **ExpressionMatrix**: Transcript counts stored as a sparse matrix, where rows are transcript/gene identifiers and columns are invididual cells.
* **GeneInformation**: A data frame containing information a set of gene identifiers, such as gene symbols or ENSEMBL transcript identifiers. This data frame also holds information on controls and any information provided by the user.
* **CellInformation**: A data frame containing each cell identifier, its associated batch/sample and additional information such as conditions.
* **Controls**: A named list featuring gene identifiers to use as controls. These gene identifiers must match the identifiers used in the expression matrix.
* **PCA**
    + PCA: PCA matrix generated by the `RunPCA` function.
    + PCAPercentVariance: Percent variance of each component. Used by the plot function `PlotPCAVariance`.
* **Clusters**
    + DistanceMatrix: Distance matrix generated from a PCA-reduced or normal expression matrix. Populated by `FindOptimalClusters`.
    + Hclust: Hclust object generated from the distance matrix. Populated by `FindOptimalClusters`.
    + PutativeClusters: Clusters generated by an unsupervised dynamic tree cut to the Hclust object. Generated by `FindOptimalClusters` function.
    + ClusteringMatrix: A matrix of clusters generated by cuts made at 40 heights, as a part of the `FindOptimalClusters` function. 
    + Clusters: List of cells and their assigned cluster. Populated by `FindOptimalClusters`.
    + NumberOfClusters: Optimal number of clusters identified by `FindOptimalClusters`.
    + OptimalTreeHeight: Optimal tree height identified by `FindOptimalClusters`.
    + KeyStats: Data frame containing information used to determine the optimal number of clusters. Generated by `FindOptimalClusters`.
    + RandMatrix: Reformatted version of KeyStats, for use with `PlotStabilityDendro`.
* **Metrics** A list of values generated by the `GenerateMetrics` function.
* **Log** A record of functions used on an AEMSet.

### Creating an AEMSet
Generally, an AEMSet can be created by using the `NewAEMSet` function. You can view a quick summary of this object by entering the name of the created object.

```{r LoadData, echo = FALSE}
data("RGC_scRNASeq")

# Quick prep of data to use as examples. Duplicate of what's done in ASCEND_Tutorial.md
batch.information <- lapply(strsplit(as.character(barcodes$V1), "-"), `[`, 2)
colnames(barcodes) <- c("cell_barcode")
barcodes$batch <- as.numeric(batch.information)
colnames(matrix) <- barcodes[,1]
colnames(genes) <- c("ensembl_id", "gene_name")
genes <- genes[,c("gene_name", "ensembl_id")]
gene.names <- make.unique(as.vector(genes$gene_name))
rownames(matrix) <- gene.names
genes$gene_name <- gene.names
mito.genes <- rownames(matrix)[grep("^MT-", rownames(matrix), ignore.case = TRUE)]
ribo.genes <- rownames(matrix)[grep("^RPS|^RPL", rownames(matrix), ignore.case = TRUE)]
control.list <- list(Mt = mito.genes, Rb = ribo.genes)
expression.matrix <- matrix
gene.information <- genes
cell.information <- barcodes
```

```{r NewAEMSet}
aem.set <- NewAEMSet(ExpressionMatrix = expression.matrix, CellInformation = cell.information, GeneInformation = gene.information, Controls = control.list)
aem.set
```

Refer to the vignette [An introduction to ASCEND - Processing and analysis of retinal ganglion cells ](ASCEND_Tutorial.md) for a walkthrough on how to create an AEMSet.

### Manipulating an AEMSet
The `ASCEND` package comes with functions dedicated to the manipulation of `AEMSets`.

#### Retrieving data from an AEMSet
Use `GetExpressionMatrix` to retrieve the expression matrix stored in an `AEMSet` as a matrix or data frame.

```{r ExtractMatrix}
data.frame <- GetExpressionMatrix(aem.set, format = "data.frame")
matrix <- GetExpressionMatrix(aem.set, format = "matrix")

data.frame[1:10,1:10]
```

Use `GetCellInfo` to retrieve the data frame stored in the CellInformation slot of the `AEMSet`.
```{r GetCellInfo}
cell.info <- GetCellInfo(aem.set)
cell.info[1:10,]
```

Use `GetGeneInfo` to retrieve the data frame stored in the GeneInformation slot of the `AEMSet`.
```{r GetGeneInfo}
gene.info <- GetGeneInfo(aem.set)
gene.info[1:10,]
```

Use `GetControls` to retrieve the controls from the `AEMSet`.
```{r GetControls}
controls <- GetControls(aem.set)
print(controls)
```

Use `GetPCA` to retrieve the PCA matrix from an `AEMSet` that has undergone PCA reduction.
```{r GetPCA, eval = FALSE}
pca <- GetPCA(aem.set)
```

Use `GetDistanceMatrix` to retrieve the distance matrix generated by the `FindOptimalClusters` function.
```{r GetPCA, eval = FALSE}
distance.matrix <- GetDistanceMatrix(aem.set)
```

Use `GetHclust` to retrieve the hclust object generated by the `FindOptimalClusters` function.
```{r GetHclust, eval = FALSE}
hclust.obj <- GetHclust(aem.set)
```

#### Modifying an AEMSet
These functions will enable you to modify the contents of a pre-existing AEMSet.

To replace the data frame in the CellInformation slot of a pre-existing AEMSet, use `ReplaceCellInfo`.
```{r ReplaceCellInfo, eval = FALSE}
updated.aem.set <- ReplaceCellInfo(aem.set, new.cell.info)
```

To replace the data frame in the GeneInformation slot of a pre-existing AEMSet, use `ReplaceGeneInfo`. 
```{r ReplaceGeneInfo, eval = FALSE}
updated.aem.set <- ReplaceGeneInfo(aem.set, new.gene.info)
```

To change or remove controls from a dataset, use `UpdateControls`. Please note that this function just removes the use of controls in an AEMSet; transcript counts associated with controls will not be removed.
```{r UpdateControls, eval = FALSE}
old.controls <- GetControls(aem.set)
new.controls <- c(old.controls, list(ERCC = c("ERCC-00031", "ERCC-00017", "ERCC-00024")))
updated.aem.set <- UpdateControls(aem.set, new.controls)
```

To replace the expression matrix in a pre-existing AEMSet, use `ReplaceExpressionMatrix`. Please note that replacing an expression matrix will recalculate the metrics associated with a dataset.
```{r ReplaceExpressionMatrix,  eval = FALSE}
updated.aem.set <- ReplaceExpressionMatrix(aem.set, new.matrix)
```

#### Subsetting from an AEMSet
If you want to use a subset of cells from a pre-existing AEMSet, you can use one of the following functions.

To subset cells by batch, use `SubsetBatch`.
```{r SubsetBatch, eval = FALSE}
subset.batch <- SubsetBatch(aem.set, batches = c("1", "2"))
```

To subset cells by cluster, use `SubsetCluster`.
```{r SubsetCluster,  eval = FALSE}
subset.clusters <- SubsetCluster(aem.set, clusters = c("2", "3"))
```

To subset cells by a condition, use `SubsetCondition`.
```{r SubsetCondition, eval = FALSE}
thy1.set <- SubsetCondition(aem.set, conditions = c("THY1"))
```

To subset cells by a list of cell identifiers, use `SubsetCells`.
```{r SubsetCells, eval = FALSE}
# Retrieve cell information from an AEMSet
cell.info <- GetCellInfo(aem.set)

# Randomly sample 100 cell barcodes to isolate.
cell.barcodes <- sample(cell.info$cell_barcode, 100, replace = FALSE)
hundred.cell.set <- SubsetCells(aem.set, cell_barcodes = cell.barcodes)
```

Be mindful of what has been done to the dataset before continuing on your analysis on the subsetted AEMSet. For example, if you subset part of a dataset that has undergone clustering and wish to perform clustering on the isolated cells - you will need to repeat the PCA reduction before clustering the dataset.

## Examples

